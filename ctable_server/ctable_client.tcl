#
# Network CTables
#
# Client-Side
#
#
# $Id$
#

#
# remote_ctable - declare a ctable as going to a remote host
#
# remote_ctable $serverHost myTable
#
#  myTable is now a command that works like a ctable except it's all
#  client server behind your back.
#
proc remote_ctable {host tableName} {
    proc $tableName {args} "remote_ctable_invoke $tableName $host \$args"
}

#
# remote_ctable_send - send a command to a remote ctable server
#
proc remote_ctable_send {host command} {
    variable hostSockets

    if {![info exists hostSockets($host)]} {
	set hostSockets($host) [socket $host 11111]
    }

    set sock $hostSockets($host)

    if {[catch {puts $sock $command; flush $sock} result] == 1} {
	puts "got $result writing to $sock, retrying"
	catch {close $hostSockets($host)}
	set hostSockets($host) [socket $host 11111]
	puts $sock $command
	flush $sock
    }

    while 1 {
	set line [gets $sock]

	switch [lindex $line 0] {
	    "e" {
		error [lindex $line 1] [lindex $line 2] [lindex $line 3]
	    }

	    "k" {
		return [lindex $line 1]
	    }

	    "m" {
		while {[gets $sock line] >= 0} {
		    puts "multiline response: $line"
		    if {$line == "\\."} {
		       puts "terminator line seen"
		       break
		    }
		}
	    }

	    default {
		error "unknown command response"
	    }
	}
    }
}

#
# remote_ctable_create - create on the specified host an instance of the ctable creator creatorName named tableName
#
proc remote_ctable_create {host creatorName tableName} {
    return [remote_ctable_send $host [list create $creatorName $tableName]]
}

#
# remote_ctable_invoke - object handler for procs generated by remote_ctable
#
proc remote_ctable_invoke {tableName host command} {
    variable hostSockets

    return [remote_ctable_send $host [linsert [lrange $command 1 end] 0 [lindex $command 0] $tableName]]
}

package provide ctable_client 1.0

