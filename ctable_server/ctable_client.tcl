#
# Network CTables
#
# Client-Side
#
#
# $Id$
#

#
# Create a place to stash the stack level
#
namespace eval ::ctable_data {
    variable topLevel
}

#
# remote_ctable - declare a ctable as going to a remote host
#
# remote_ctable $serverHost myTable
#
#  myTable is now a command that works like a ctable except it's all
#  client server behind your back.
#
proc remote_ctable {host tableName} {
    proc $tableName {args} "
	set ::ctable_data::topLevel \[info level]
	remote_ctable_invoke $tableName $host \$args
    "
}

#
# remote_ctable_send - send a command to a remote ctable server
#
proc remote_ctable_send {host command {actionData ""}} {
    variable hostSockets

#puts "actionData '$actionData'"

    if {![info exists hostSockets($host)]} {
	set hostSockets($host) [socket $host 11111]
    }

    set sock $hostSockets($host)

    if {[catch {puts $sock $command; flush $sock} result] == 1} {
	puts "got $result writing to $sock, retrying"
	catch {close $hostSockets($host)}
	set hostSockets($host) [socket $host 11111]
	puts $sock $command
	flush $sock
    }

    while 1 {
	set line [gets $sock]

	switch [lindex $line 0] {
	    "e" {
		error [lindex $line 1] [lindex $line 2] [lindex $line 3]
	    }

	    "k" {
		return [lindex $line 1]
	    }

	    "m" {
		array set actions $actionData
		set firstLine 1

		set mylevel [info level]
	        set upLevel [expr {$mylevel - $::ctable_data::topLevel + 1}]

		while {[gets $sock line] >= 0} {
		    if {$line == "\\."} {
			break
		    }
#puts "processing line '$line'"

		    if {[info exists actions(-write_tabsep)]} {
			puts $actions(-write_tabsep) $line
		    } elseif {[info exists actions(-code)]} {
			if {$firstLine} {
			    set firstLine 0
			    set fields $line
			    continue
			}

#puts "fields '$fields' value '$line'"
			set result ""
			foreach var $fields value [split $line "\t"] {
#puts "var '$var' value '$value"
			    if {$var == "_key"} {
				if {[info exists actions(keyVar)]} {
#puts "set $actions(keyVar) $value"
				    uplevel 1 set $actions(keyVar) $value
				}
				continue
			    }

			    if {[info exists actions(-get)]} {
				lappend result $value
			    } else {
				lappend result $var $value
			    }
			}

			uplevel $upLevel "
			    [list set $actions(bodyVar) $result]
			    $actions(-code)
			"
		    } else {
			error "no action, need -write_tabsep or -code: $actionData"
		    }
		}
	    }

	    default {
		error "unknown command response"
	    }
	}
    }
}

#
# remote_ctable_create - create on the specified host an instance of the ctable creator creatorName named tableName
#
proc remote_ctable_create {host creatorName tableName} {
    return [remote_ctable_send $host [list create $creatorName $tableName]]
}

#
# remote_ctable_invoke - object handler for procs generated by remote_ctable
#
proc remote_ctable_invoke {tableName host command} {
    variable hostSockets

    set cmd [lindex $command 0]
    set body [lrange $command 1 end]

#puts "cmd '$command', pairs '$body'"

    # if it's search, take out args that will freak out the remote side
    if {$cmd == "search"} {
	array set pairs $body
	if {[info exists pairs(-write_tabsep)]} {
	    set actions(-write_tabsep) $pairs(-write_tabsep)
	    unset pairs(-write_tabsep)
	}

	if {[info exists pairs(-code)]} {
	    set actions(-code) $pairs(-code)
	    unset pairs(-code)

	    foreach var {-key -array_get -array_get_with_nulls -get} {
		if {[info exists pairs($var)]} {
		    set actions($var) $pairs($var)
		    unset pairs($var)

		    if {$var == "-key"} {
			set actions(keyVar) $actions($var)
		    } else {
			set actions(bodyVar) $actions($var)
		    }
		}
	    }

	    set pairs(-include_field_names) 1
	}
	set body [array get pairs]
#puts "new body is '$body'"
#puts "new actions is [array get actions]"
    }

    return [remote_ctable_send $host [linsert $body 0 $cmd $tableName] [array get actions]]
}

package provide ctable_client 1.0

