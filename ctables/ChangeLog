
$Id$

11/22/2006 karl
    * Factored out a 702-line piece of code for the main body of
      generated ctable code into its own file to make things
      more manageable.

11/21/2006 karl
    * write_tabsep now works (or again works) if no field names
      are specified.

11/15/2006 karl
    * Switch debugging off by default.

    * Add the -nokey switch to import_tabsep and export_tabsep.  If set,
      export_tabsep will not include the key in what it emits, and 
      import_tabsep will self-generate an ascending integer key when
      importing.

    * Make linking with debug libraries and generating with compiler
      debugging more parameterized.

    * Make sort comparison of MAC and IP addresses work better or,
      more to the point, work at all.

    * When a row fails input checks during read_tabsep, report the line
      number in the error message.

    * Update documentation.

11/1/2006 karl
    * Add a sort method that lets you sort on multiple fields and call
      through to a callback that processes them in order, like foreach.
      Can't currently do descending and arguments are positional --
      would like to have a "walk" method that can sort, etc.

9/14/2006 karl
    * Expand the set command to allow it to take a list of key-value
      pairs in addition to its existing functionality.  This allows
      replacing     eval foo set $key [array get dataArray]
      with          foo set $key [array get dataArray]

9/9/2006 karl
    * Add an ability to specify a pattern when reading and writing
      tab-separated data.  Currently supports "-glob pattern" in
      the read_tabsep and write_tabsep methods.  Pattern is compared
      to the key field.

8/15/2006 karl
    * Make the optional match pattern on "foreach" precede the code body
      rather than come after it.

7/19/2006 karl
    * Fairly decent job of documenting things as they are, although currently
      only in a "straight text" style.

7/10/2006 karl
    * Detect defining a table with no fields and report as an error rather
      than generating stuff the C compiler can't understand.

    * Catch errors defining ctables and save off the errorInfo traceback
      that's basically internal to ctable.  Made a new proc,
      ::ctable::get_error_info, that will return that info, and include
      a note in the error message to run that proc to see the internal
      errorInfo traceback.

    * Create new method, export, that's the analog of import.  It will
      export all fields or specified fields from each stored row by
      repeated calling the passed proc with an argument consisting of
      a list containing the key and all specified fields (or all fields,
      if no fields are specified.)

    * New C routines, *_dstring_append_get_tabsep that will generate
      tab-separated (and newline-terminated) fields from a row
      into a DString, and *_export_tabsep that will write all the
      rows in a table, tab-separated, to a channel.

    * Add of write_tabsep method that will write all of the fields, or
      the named fields, tab-separated, to the specified Tcl channel.
      Note that this currently does no quoting to make sure that
      tabs or newlines in strings don't screw things up.

    * New C routines, *_set_from_tabsep that will take a pointer to
      a row, a tab-separated import string, an array of field numbers
      and a number of fields and set the values into the row.  The
      first field is the key.
      *_import_tabsep reads lines from a channel and
      invokes *_set_from_tabsep on each line.

    * Add of read_tabsep method that, using the above routines,  will read 
      all of the fields, or the named fields, tab-separated, from the 
      specified Tcl channel.  Note that, like write_tabsep, this currently 
      does no quoting to make sure that tabs or newlines in strings don't 
      screw things up.

    * Make subobj datatype work again.

7/6/2006 karl
    * Fix the build on Darwin to not use the Postgres stuff.  Still haven't
      gotten the shared library on Darwin to work properly with the
      libpq and libpgtcl libraries.

7/5/2006 karl
    * Add a new method, array_get_nonnull, that will only return nonnull
      key-value pairs.

    * Make array_get work like array_get_nonnull, removing array_get_nonnull.
      Create array_get_with_nulls that replaces the prior behavior of
      array_get.

    * Added a new *_set_null function that, given a pointer to a row and
      a field number, will set the corresponding field's null value bit
      to true.  Note, there will be no reciprocal *_set_nonnull function
      because when the null bit is set, the corresponding value is
      undefined -- the only way to set a field nonnull is to set a value
      into it with the corresponding table's *_set routine.

    * New import_postgres_result can import a multirow PostgreSQL result
      directly into a ctable without any intervening per-row Tcl.  This
      is extremely fast.  Excluding the pg_exec overhead, on a 2.2 GHz
      AMD64 we can import 210,000 8-element rows per second.

7/4/2006 karl
    * Add a new method, null_value, to the meta table object that sets
      a null value that is returned by set and get when a field's value
      hasn't been set or has been set with the defined null_value.
      The default is an empty string.

    * Rework default stuff so that if a default value is defined, upon
      init of a new row, elements with default values will be set with
      the default values and the corresponding null value bits will be
      set to say that the elements are not null.  Anything without a
      default value predefined has its null bit set.

    * Change the syntax of the CExtension command to require a version
      number and take the code as the third argument.  This means the
      enter extension code body is specified on the CExtension command
      line via "{...}", which allowed EndExtension to move into the
      ctable namespace and be invoked automatically by CExtension at
      the end of code generation.  This will allow us to scarf off a
      complete copy of the code being fed to CExtension, which will
      let us see if it's the same as we got last time and keep us from
      doing a generate/compile/link phase if nothing's changed.

    * Create a CTableBuildPath command that sets where we will build.
      Include the version number in the filename of the generated C
      source and the object file that we compile to.

    * Scarf off the CExtension source code and compare it to what we're
      being asked to build now.  If they're the same, don't bother.

    * Record the CVS ID of the CTable generator in the scarfed off
      CExtension source code file (.ct file).  When checking to see
      if a build is necessary, also compare them.  If they don't match,
      do the build.  This way, if there's any change in the generator
      software, a build will occur even if the CExtension code hasn't
      changed.

    * Add the build path to the auto_path if it's not already there.
      Do a pkg_mkIndex on the build directory if we generated something.
      (This makes "package require" work for the extension we created.)

    * Add a Makefile.  It's currently lame.  Add automation to copy
      qhehe.h to the target directory if there isn't something there matching.


7/2/2006 karl
    * Keep track of string lengths for varstring fields to prevent lots
      of unnecessary counting and to lay the groundwork for character
      quoting that we'll be implementing soon, with a tradeoff off somewhat 
      larger row size as we're carrying string lengths along with pointers
      to strings in each rows.

    * For varstrings, create a Tcl_Obj containing the default value and
      increment its reference count at setup time, and when returning the 
      default value, simply return a pointer to that Tcl_Obj rather than
      creating a new string obj.

    * Optimization for varstring defaults.  If the default is an empty
      string, only generate one empty string obj default and use that
      as the default for each varstring with an empty string, rather than 
      creating an empty obj for each.

    * *_get C function now returns a (Tcl_Obj *) to an object representing
      the thing you asked for, rather than appending to a list on the
      Tcl result.  This makes it much more useful from C.

    * Now generating *_get_string function that takes a pointer to a row,
      a field in the row, a pointer to a length integer and a pointer to
      a Tcl_Obj that we use for utility purposes and it generates or
      otherwise finds the string and returns a pointer to the string,
      setting the length pointer to the length of the string if the length
      pointer isn't NULL.

    * Tagged Revision 1.1 (rev1_1)

    * When setting a string, compare that string to the default value and
      if it is the same as the default value, store a null pointer rather
      than allocating the string, copying it, and storing that pointer.
      When fetching a string, as before, provide the default value if the
      pointer within the row is null.

    * Enforce that field names must start with a letter and can contain
      only upper and lowercase letters, digits, and underscores.

    * Quote backslash sequences and control characters that are to
      appear in C strings using a cquote function generated by Peter
      at the next desk over at 6 pm on 7/3/2006.  Thank you, Peter.

    * Fix bug in array_get where no keys are specified.  It was
      returning exactly half as many fields as it should have. Oops.


7/1/2006 karl
    * Generate enum entries for fields using a proc.  That proc makes the
      field names unique, for example, FIELD_MAC now becomes for table
      "cable_device", FIELD_CABLE_DEVICE_MAC.

    * Add new "array_get" method that will let you one or more fields,
      or all fields, in "array get" format, i.e. key value [key value...]"

    * Make it work under FreeBSD as well as Darwin.  Eventually we will
      have to at least parse tclConfig.sh and possibly even have our
      own GNU autoconf thang.

    * Emit a enumerated typedef for the CTable types.  Also enumerate
      a corresponding array of char pointers containing the type names.

    * Emit an enum *_types for each defined table that has the enumerated
      ctable type for each field in the table.  This will allow us at
      runtime to easily and efficiently determine the type of any field from 
      C.  Soon, from Tcl as well.

    * Add of new method, fieldtype, which will return the CTable type of
      the passed-in field.

    * Add of new method, needs_quoting, which returns one if the passed-in
      field requires or may require quoting (i.e. could contain characters
      that could trip up a database insert, CSV export, or something like
      that.)

