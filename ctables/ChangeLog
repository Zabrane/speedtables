
$Id$

12/19/2006 karl
    * Proceduralize generating index inserting and deleting code and
      don't generate it for a field when an index isn't defined on that
      field.

12/18/2006 karl
    * Fix bug where skip list code assumed it would get 64 bits of random
      number instead of the 32 it got, making skip lists really slow
      on 64-bit machines like AMD64 (where sizeof(size_t) == 8)

    * Moved where the *_setup routine got called when initializing a
      creator table so the per-field field name object pointers got
      set properly.  This fixes "indexed" and "indexable" options to
      "index" method.

12/16/2006 karl
    * Added "indexable" and "indexed" suboptions to the ctable "index"
      method to list the names of the fields that can be indexed
      (indexes were defined on the fields when the table was created)
      and to list the names of the fields that have indexes currently
      defined against them.

12/15/2006 karl
    * Fixed sort to work in both search and search+.  (It previously did not
      work with search+.)  Fold ctable_SearchAction and ctable_SkipSearchAction
      into one, also gaining the ability to specify -key in search+.

    * Fixed bug in "reset" method, introduced with indexes, where indexes
      weren't getting deleted and the doubly linked list of all rows was
      not getting reset.

    * Created 25 pages of ctables documentation in Pages, starting with
      doc.txt.

12/14/2006 karl
    * Indexes now support duplicate entries.

12/7/2006 karl
    * Major performance boost by maintaining a linked list among all of
      the rows of a table and walking that while searching rather than
      enumerating the hash table.  Increased search performance from
      for a brute-force unanchored text search of 1,000,000 rows by
      more than threefold.

    * Implement an array of linked list nodes defined in the row
      structure definition, one for all rows (index 0) and the rest
      for fields declared as indexable, in preparation for supporting
      indexes that can contain duplicate entries.  Also they're defined
      in such a way that they are guaranteed to be in the same place in
      all rows so different code can use a "base row" definition and
      access the linked list nodes without having been generated to
      understand the data that follows it.

12/6/2006 karl
    * Added code to repeatably generate the test data in bigtests and got 
      rid of the 24 meg file of test data that was previously there.

12/5/2006 karl
    * Version 3.0 tagged for release.

    * Resolve the bugs in search with offset and limit specified and
      the different results whether it was sorted or unsorted.

    * Merge the skiplist development branch back into the mainline ctables
      CVS branch.

    * Bring search limit with and without sort into compliance that limit is 
      the limit on the number of rows returned.

    * Revived "write_tabsep" and "foreach" at the request of the userbase,
      although they are still to be considered deprecated.

    * Make $table index create $field take an optional argument which is
      the depth of the skip list, like 24 would be good if you had 4M
      rows.  (This should be more hidden but it's still in dev.)

    * When building for source-level debugging, still use some level
      of optimization.

    * Updated docs to reflect usage of "index" method and fully document
      "search" method.

    * Fix up argument error message for search to include all the options.

12/4/2006 karl
    * Skip list indexes are working for creation, dropping, inserting,
      updating, and searching.

    * Added "search+" that works like search but on skip lists instead
      of the hash table.  This isn't the permanent solution.

    * Added pointers to functions to make empty rows, set elements
      of rows, set elements of rows to null, get values from rows
      to the ctable table structure.  It's getting to where
      you can write all sorts of high speed C ctable access stuff
      that isn't tailored to a specific data structure.

      Internally you see this in how much code is in ctable_search.c
      and how that code makes use of these pointers to access fields
      in tables without knowing how those tables are structured.

    * Got rid of generating custom pointer names in tons of places,
      substituting "row" instead, significantly simplifying the
      code.

    * "...index count $field" is now working. 

    * Attempts to insert duplicate entries in skip lists is now an error.
      We'll eventually support having duplicate keys but not currently.

    * Propagate the Tcl interpreter pointer, ctable pointer, and whether 
      a row is new or not into *_set, *_set_fieldobj, *_incr, 
      *_incr_fieldobj and *_set_null routines.  It's a lot of overhead
      to allow fields in a table to be indexed on demand, but since
      we're generating the code, we can also not generate if we're
      somehow told there won't be indexes or on what fields there
      won't be indexes.

12/3/2006 karl
    * Add "list" option to "... index" to get a list of indices for
      the given field's index.  While this will be wildly inefficient
      with hundreds of thousands of records, it's handy to facilitate
      testing and verification that the indexes are in sync.

    * Add "count" option to "... index" method to get the count.
      Currently inoperative as the skip list library defined the
      count but doesn't manage it.  We'll fix that shortly.

    * Add "notnull 1" options to inhibit generation of null check code
      for a field.  **Incomplete**  be addressed in numerous places
      and may not even be worth it(?)

    * Tighten up generated code by stripping leading and trailing newline
      from substituted multi-line elements.

12/2/2006 karl
    * Propagate the ctableTable pointer down into the ${table}_set
      routine in preparation of handling triggers/indexes.

    * Create a "dump" suboption for indexes.

    * Propagate a pointer to the table-specific ${table}_get_string function
      into the creatorTable struct for the corresponding table to that
      routines with no specific awareness of how a table has been
      generated can still get the contents of fields and stuff.


12/1/2006 karl
    * Generate new per-field row-to-row comparison routines for use with
      skip lists and, eventually, sort comparisons and search comparisons.

    * For each table create an array of pointers to field compare functions 
      indexed by field number.

    * When creating a skip list, store the compare function by getting it
      from the creator table structure.

    * Add new ctable method, "index", with subcommands "create" and "drop"

    * Remove deprecated "foreach", "sort", "write_tabsep", "import"
      and "export" methods.

    * Migrate another hundred lines out of gentable.tcl and into
      command-body.c-subst, reducing complexity in gentable.tcl.

11/30/2006 karl
    * Standardize field creation to always be key-value pairs, so you
      now might say "varchar foo default bar" instead of
      "varchar foo bar" so that you can do other stuff like
      "index 1 unique 1"

    * Make new command the same name as the extension name, except the first
      char is uppercase (strangely, something to do with TEA), that will
      give you back the definition that made the C extension in the first
      place.

    * Add new method to tables, cextension, that returns the C extension
      that defined them.

    * Created skiplist development branch.  Got skiplist code to
      install in the ctable package and compile cleanly within 
      ctables.  Merged development branch back into mainline.

11/29/2006 karl
    * Tagged 2_0 for release.

    * Doubled performance for searches with "match" components
      where we use ultra-fast Boyer-Moore when the search is unanchored
      (*pattern*) and not too fancy (no embedded []?*\ characters).

    * Add a switch to gentable.tcl to show compiler command lines.

11/28/2006 karl
    * Fix bug where, when searching with no sorting and a limit, you'd get
      one less record than you'd asked for even if one more was available.

11/26/2006 karl
    * Add -include_field_names to search.  If set to true and using
      -write_tabsep, will make the first line be the field names
      that matching.

    * Manage varstring space a little more efficiently by not freeing
      the string whenever it gets set if it's already set.  By looking
      to see what was allocated, we reuse what's there if it's big enough.

    * Add "incr" method.  It takes take key-value pairs or a list of
      key-value pairs.  It will increment each numeric field by
      the corresponding amount and return a list of the new values
      of all incremented fields.

    * Add new compare methods "match" and "match_case" that perform
      a Tcl_StringMatch on the field (currently varchar-only) and
      select it if it matches else skips it.  match is case-insensitive
      and match_case is case-sensitive.

11/25/2006 karl
    * In search's -sort option, fields in the field list that begin with
      a dash are sorted in descending order rather than ascending order.

    * Make "null" and "notnull" comparisons work.

11/24/2006 karl
    * Rename search's -list option to -get.  Rename its -array to -array_get
      and add -array-get_with_nulls.

    * Pull the number of fields, array of field types and array of elements
      needing quoting into the table creator structure.

    * Bring pointers to functions lappend_field_and_nameobj and
      lappend_nonnull_field_and_nameobj into the table creator structure.

    * If no reference fields are specified with a search (-fields list),
      you get all fields by default.

    * Convert ${table}_gen_nonnull_keyvalue_list and 
      ${table}_gen_keyvalue_list to return a Tcl_Obj rather than
      setting the interpreter result object and return TCL_OK
      so that they're more general purpose.  Modify code that
      previously called this to set the interpreter obj result
      with the result.

11/23/2006 karl
    * The "foreach" and "sort" methods are deprecated in favor of
      "search" but will be left in until legacy code can be updated.

    * Simplify things by using standardized table creator and table
      structures rather than generating custom ones for each 
      ctable -- we hide the differences behind the value of the
      hashtable and cast in our custom-generated code.

    * Get rid of the TAILQ stuff -- it wasn't fully implemeneted and
      was a good idea but it's also hackish in terms of it's cpp
      macros that create all the forward and backward casts -- needs
      thought.

    * Migrate standardized structures that are not custom-generated
      into a new include file, ctable.h

    * Reference the registered proc table pointer from the master
      structure for the ctable type.

11/22/2006 karl
    * Factored out a 702-line piece of code for the main body of
      generated ctable code into its own file to make things
      more manageable.

11/21/2006 karl
    * write_tabsep now works (or again works) if no field names
      are specified.

11/15/2006 karl
    * Switch debugging off by default.

    * Add the -nokey switch to import_tabsep and export_tabsep.  If set,
      export_tabsep will not include the key in what it emits, and 
      import_tabsep will self-generate an ascending integer key when
      importing.

    * Make linking with debug libraries and generating with compiler
      debugging more parameterized.

    * Make sort comparison of MAC and IP addresses work better or,
      more to the point, work at all.

    * When a row fails input checks during read_tabsep, report the line
      number in the error message.

    * Update documentation.

11/1/2006 karl
    * Add a sort method that lets you sort on multiple fields and call
      through to a callback that processes them in order, like foreach.
      Can't currently do descending and arguments are positional --
      would like to have a "walk" method that can sort, etc.

9/14/2006 karl
    * Expand the set command to allow it to take a list of key-value
      pairs in addition to its existing functionality.  This allows
      replacing     eval foo set $key [array get dataArray]
      with          foo set $key [array get dataArray]

9/9/2006 karl
    * Add an ability to specify a pattern when reading and writing
      tab-separated data.  Currently supports "-glob pattern" in
      the read_tabsep and write_tabsep methods.  Pattern is compared
      to the key field.

8/15/2006 karl
    * Make the optional match pattern on "foreach" precede the code body
      rather than come after it.

7/19/2006 karl
    * Fairly decent job of documenting things as they are, although currently
      only in a "straight text" style.

7/10/2006 karl
    * Detect defining a table with no fields and report as an error rather
      than generating stuff the C compiler can't understand.

    * Catch errors defining ctables and save off the errorInfo traceback
      that's basically internal to ctable.  Made a new proc,
      ::ctable::get_error_info, that will return that info, and include
      a note in the error message to run that proc to see the internal
      errorInfo traceback.

    * Create new method, export, that's the analog of import.  It will
      export all fields or specified fields from each stored row by
      repeated calling the passed proc with an argument consisting of
      a list containing the key and all specified fields (or all fields,
      if no fields are specified.)

    * New C routines, *_dstring_append_get_tabsep that will generate
      tab-separated (and newline-terminated) fields from a row
      into a DString, and *_export_tabsep that will write all the
      rows in a table, tab-separated, to a channel.

    * Add of write_tabsep method that will write all of the fields, or
      the named fields, tab-separated, to the specified Tcl channel.
      Note that this currently does no quoting to make sure that
      tabs or newlines in strings don't screw things up.

    * New C routines, *_set_from_tabsep that will take a pointer to
      a row, a tab-separated import string, an array of field numbers
      and a number of fields and set the values into the row.  The
      first field is the key.
      *_import_tabsep reads lines from a channel and
      invokes *_set_from_tabsep on each line.

    * Add of read_tabsep method that, using the above routines,  will read 
      all of the fields, or the named fields, tab-separated, from the 
      specified Tcl channel.  Note that, like write_tabsep, this currently 
      does no quoting to make sure that tabs or newlines in strings don't 
      screw things up.

    * Make subobj datatype work again.

7/6/2006 karl
    * Fix the build on Darwin to not use the Postgres stuff.  Still haven't
      gotten the shared library on Darwin to work properly with the
      libpq and libpgtcl libraries.

7/5/2006 karl
    * Add a new method, array_get_nonnull, that will only return nonnull
      key-value pairs.

    * Make array_get work like array_get_nonnull, removing array_get_nonnull.
      Create array_get_with_nulls that replaces the prior behavior of
      array_get.

    * Added a new *_set_null function that, given a pointer to a row and
      a field number, will set the corresponding field's null value bit
      to true.  Note, there will be no reciprocal *_set_nonnull function
      because when the null bit is set, the corresponding value is
      undefined -- the only way to set a field nonnull is to set a value
      into it with the corresponding table's *_set routine.

    * New import_postgres_result can import a multirow PostgreSQL result
      directly into a ctable without any intervening per-row Tcl.  This
      is extremely fast.  Excluding the pg_exec overhead, on a 2.2 GHz
      AMD64 we can import 210,000 8-element rows per second.

7/4/2006 karl
    * Add a new method, null_value, to the meta table object that sets
      a null value that is returned by set and get when a field's value
      hasn't been set or has been set with the defined null_value.
      The default is an empty string.

    * Rework default stuff so that if a default value is defined, upon
      init of a new row, elements with default values will be set with
      the default values and the corresponding null value bits will be
      set to say that the elements are not null.  Anything without a
      default value predefined has its null bit set.

    * Change the syntax of the CExtension command to require a version
      number and take the code as the third argument.  This means the
      enter extension code body is specified on the CExtension command
      line via "{...}", which allowed EndExtension to move into the
      ctable namespace and be invoked automatically by CExtension at
      the end of code generation.  This will allow us to scarf off a
      complete copy of the code being fed to CExtension, which will
      let us see if it's the same as we got last time and keep us from
      doing a generate/compile/link phase if nothing's changed.

    * Create a CTableBuildPath command that sets where we will build.
      Include the version number in the filename of the generated C
      source and the object file that we compile to.

    * Scarf off the CExtension source code and compare it to what we're
      being asked to build now.  If they're the same, don't bother.

    * Record the CVS ID of the CTable generator in the scarfed off
      CExtension source code file (.ct file).  When checking to see
      if a build is necessary, also compare them.  If they don't match,
      do the build.  This way, if there's any change in the generator
      software, a build will occur even if the CExtension code hasn't
      changed.

    * Add the build path to the auto_path if it's not already there.
      Do a pkg_mkIndex on the build directory if we generated something.
      (This makes "package require" work for the extension we created.)

    * Add a Makefile.  It's currently lame.  Add automation to copy
      qhehe.h to the target directory if there isn't something there matching.


7/2/2006 karl
    * Keep track of string lengths for varstring fields to prevent lots
      of unnecessary counting and to lay the groundwork for character
      quoting that we'll be implementing soon, with a tradeoff off somewhat 
      larger row size as we're carrying string lengths along with pointers
      to strings in each rows.

    * For varstrings, create a Tcl_Obj containing the default value and
      increment its reference count at setup time, and when returning the 
      default value, simply return a pointer to that Tcl_Obj rather than
      creating a new string obj.

    * Optimization for varstring defaults.  If the default is an empty
      string, only generate one empty string obj default and use that
      as the default for each varstring with an empty string, rather than 
      creating an empty obj for each.

    * *_get C function now returns a (Tcl_Obj *) to an object representing
      the thing you asked for, rather than appending to a list on the
      Tcl result.  This makes it much more useful from C.

    * Now generating *_get_string function that takes a pointer to a row,
      a field in the row, a pointer to a length integer and a pointer to
      a Tcl_Obj that we use for utility purposes and it generates or
      otherwise finds the string and returns a pointer to the string,
      setting the length pointer to the length of the string if the length
      pointer isn't NULL.

    * Tagged Revision 1.1 (rev1_1)

    * When setting a string, compare that string to the default value and
      if it is the same as the default value, store a null pointer rather
      than allocating the string, copying it, and storing that pointer.
      When fetching a string, as before, provide the default value if the
      pointer within the row is null.

    * Enforce that field names must start with a letter and can contain
      only upper and lowercase letters, digits, and underscores.

    * Quote backslash sequences and control characters that are to
      appear in C strings using a cquote function generated by Peter
      at the next desk over at 6 pm on 7/3/2006.  Thank you, Peter.

    * Fix bug in array_get where no keys are specified.  It was
      returning exactly half as many fields as it should have. Oops.


7/1/2006 karl
    * Generate enum entries for fields using a proc.  That proc makes the
      field names unique, for example, FIELD_MAC now becomes for table
      "cable_device", FIELD_CABLE_DEVICE_MAC.

    * Add new "array_get" method that will let you one or more fields,
      or all fields, in "array get" format, i.e. key value [key value...]"

    * Make it work under FreeBSD as well as Darwin.  Eventually we will
      have to at least parse tclConfig.sh and possibly even have our
      own GNU autoconf thang.

    * Emit a enumerated typedef for the CTable types.  Also enumerate
      a corresponding array of char pointers containing the type names.

    * Emit an enum *_types for each defined table that has the enumerated
      ctable type for each field in the table.  This will allow us at
      runtime to easily and efficiently determine the type of any field from 
      C.  Soon, from Tcl as well.

    * Add of new method, fieldtype, which will return the CTable type of
      the passed-in field.

    * Add of new method, needs_quoting, which returns one if the passed-in
      field requires or may require quoting (i.e. could contain characters
      that could trip up a database insert, CSV export, or something like
      that.)

