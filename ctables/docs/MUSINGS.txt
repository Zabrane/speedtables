

$Id$

I want a lot of flexibility setting and getting but without having a ton
of different ways to do it that are stupid.

Peter pointed out that SQL does it in different ways.  For example, with
inserts you have a list of fields being inserted and a list of the data,
but with update, it's key-value.

A lot of the time key-value is handier, but when bulk-loading data, I more
want to suck the stuff out of a list.


the way it works right now:

foo set $key field value field value field value...

foo get $key field field field field - returns a list of the values matching
the requested fields

foo get $key - returns a list of all of the values in field definition order


SETTING FOR THE FUTURE

The thing is, I want to import, like, a big file or something...

Then it'll be a list of data with a separate list of fields to import

So it could either be something like

foo import $key $fields $values

or

foo import $key $values field field field field field

or all fields if no fields are specified

Status:  Implemented

I might also want to import from an array

foo set $key -array arrayName  - do all of the fields in the array
 
foo set $key -array arrayName field field field field - do only the specified
fields

Set From Array Status: Not Implemented

Note: There is no easy way from a C extension to tell what the elements of
an array are without Eval'ing Tcl code, so we will probably require the
fields.  This can also easily be done by doing a

foo set key field1 $array(field1) field2 $array(field2) ...


GETTING FOR THE FUTURE

It will be real common to want to pull stuff into an array

foo get $key -array arrayName

Sometimes I won't want all the fields.  It will be much more efficient
when I don't need them all, to not convert them all back to Tcl.

foo get $key -array arrayName field field field field

I may also want to write out key-value pairs, not just values.

foo get $key -pairs field field field field

returns

key value key value key value

key-value fetch status:  Implemented



==========

Implementation

The problem is that set is pretty hard-coded, and its functionality needs
to be factored and made more general-purpose.

I think I need to factor out a routine that lets me pass a field name,
a pointer, and an object that contains the value to be set.

YES - with that, the rest becomes much easier.



========

INCREDIBLY FAST IMPORTING

What we want to do here is get a field name list and find the enumerated
field numbers in advance of looping on the import, so we only do the
lookup once.

something like

foo import code field field field field

code is executed repeatedly and is expected to return a list of the
proper length every time.

If it returns a break (TCL_BREAK), we stop.

Otherwise we take the first field as the key and each subsequent field
gets assigned in turn

if no fields are named, it expects them all to be there

Status: Implemented

========

For "foreach" and "names" methods, accept an optional argument that's
a Tcl_Match pattern.

Status:  Implemented


========

TRACKING FIELDS THAT CHANGE AND TAKING ACTIONS WHEN THINGS CHANGE

I have an interest in knowing that fields have changed.  If a field hasn't
changed, then it doesn't have to be included when, say, generating an
update back to a SQL database.

However, a CTable user may not always want this capability, so if we
implement this you will be able to specify whether you want a CTable you 
were generating to include code (and bit fields) for this or not.

When using this capability, a "dead band" should also be specifiable.  For
instance, we may be uninterested in recording a change in a floating point
field unless it has deviated by, say, more than 0.02 from its current
value.  This would mean that we would need to keep two values for numeric
fields, the last value emitted and the last value read, so that gets would
return the last value read but deadband checks would be against the last
value emitted (or if not emitted, the first value set), to guard against
any sort of deadband creep.

Finally, it could be useful to have some kind of trigger processing.  You
would define limits for a value and if a value was set within those various
limits, than pre-specified actions would be taken.  For example, alarms
would be generated.

In conjunction with the above deadband, or actually specifically related
to alarms, a deadband would prevent an alarm from "fibrillating".

For example, say there was an alarm generated when a disk drive hit
95% of its capacity, and due to activity on the disk, it was flipping between
94.99% and 95.01% of capacity several times a minute.  Rather than generating
numerous alarms and return-to-normals per minute, deadband processing might
require, for instance, that the drive usage drop to 94.0% before a return
to normal was issued.

This work has previously been implemented by Karl as Itcl alarm classes.

It would be acceptable for limit trips to cause Tcl code to be interpreted --
i.e. I don't think it would be necessary to try to avoid Tcl processing of
alarm processing code by supporting handling trigger processing directly in C,
although that isn't to say that we couldn't.

========

When loading a file, allow globbing of the key field as requested by Peter.

Status:  Implemented

========

QUERIES

Make a pass over all the rows, fetching requested variables into Tcl variables
and evaluating a Tcl expression on each one.  If the expression returns true,
save off a pointer to that row into an array of pointers equal in number of
elements to the number of elements in the table.

Also a select all will copy every row's pointer into the query result table.

SORT

Along with the query function, provide a way to sort on any field, or even
more than one field, by creating a sort comparison routine that functions at
the C level and feeding it to qsort_r.

C QUERIES

Queries implemented directly in C would be much faster than ones based on Tcl
but would basically have to either be predefined or generated, compiled and
linked as a shared library on the fly.  For a first implementation, only allow
them to be defined at compile time.  This ties into earlier proposed ways to
specify C code to be compiled, linked and loaded along with the autogenerated
ctable code.


=======

x select varList expression code


