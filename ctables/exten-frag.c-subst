    /*
     * CTable code fragment to do metatable allocation that goes inside the
     * package *_Init code.
     *
     * $Id$
     *
     * Create the master table that has the registered proc table and stuff.
     *
     *  define the following variables and subst this:
     *   table
     */

    t = (struct ctableCreatorTable *)ckalloc (sizeof (struct ctableCreatorTable));

    /* create the table for registering Tcl commands to appear as methods
     * of the table class and pass it in through Tcl's client data
     * mechanism
     */
    hashTablePtr = (Tcl_HashTable *)ckalloc (sizeof (Tcl_HashTable));
    Tcl_InitCustomHashTable (hashTablePtr, TCL_STRING_KEYS, NULL);

    t->registeredProcTablePtr = hashTablePtr;
    t->nextAutoCounter = 0;
    t->fieldNames = ${table}_fields;
    t->nameObjList = ${table}_NameObjList;

    t->nFields = $NFIELDS;
    t->fieldTypes = ${table}_types;
    t->fieldsThatNeedQuoting = ${table}_needs_quoting;

    // pointers to functions
    t->make_empty_row = (void *)${table}_make_row_struct;
    t->set = (void *)${table}_set;
    t->set_null = (void *)${table}_set_null;

    t->get = ${table}_get;
    t->get_string = ${table}_get_string;

    t->gen_list = ${table}_genlist;
    t->gen_keyvalue_list = ${table}_gen_keyvalue_list;
    t->dstring_append_get_tabsep = ${table}_dstring_append_get_tabsep;
    t->lappend_field = ${table}_lappend_field;
    t->lappend_field_and_name = ${table}_lappend_field_and_name;
    t->lappend_nonnull_field_and_name = ${table}_lappend_nonnull_field_and_name;

    t->search_compare = ${table}_search_compare;
    t->sort_compare = ${table}_sort_compare;

    // allocate and populate the field info structures
    t->fields = (struct ctableFieldInfo **)ckalloc (t->nFields * sizeof (struct ctableFieldInfo *));
    for (i = 0; i < t->nFields; i++) {
        struct ctableFieldInfo *f;

        f = t->fields[i] = (struct ctableFieldInfo *)ckalloc (sizeof (struct ctableFieldInfo));

	f->name = ${table}_fields[i];
	f->nameObj = ${table}_NameObjList[i];
	f->number = i;
	f->type = t->fieldTypes[i];
	f->needsQuoting = ${table}_needs_quoting[i];
	f->compareFunction = ${table}_compare_functions[i];
    }

    // make a field list -- sure it's a little hokey but it works with
    // other places that take a number of fields and list of fields
    // and with this you can always get all of them
    t->fieldList = (int *)ckalloc (t->nFields * sizeof (int));
    for (i = 0; i < t->nFields; i++) {
	t->fieldList[i] = i;
    }

    ${table}_setup ();

    /* Create the ${table}MetaObjCmd command -- it's fairly equivalent to an
     * Itcl class in that it can create its own commands with their
     * own data spaces, etc.
     */
    Tcl_CreateObjCommand(interp, "${table}", (Tcl_ObjCmdProc *) ${table}MetaObjCmd, (ClientData)t, (Tcl_CmdDeleteProc *)NULL);

