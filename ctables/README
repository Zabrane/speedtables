

$Id$

CTABLE

This is code to creates tables of rows where rows consist of fields, in Tcl.

It takes the definition of one or more tables and generates C code that can 
is then compiled and linked as a C shared library extension for Tcl,
providing high performance tables that are far more memory-efficient than
using array of lists lists of lists, Itcl objects, etc.


CTable fa_position {
    long timestamp
    short latitude
    short longitude
    short groundspeed
    short altitude
    char altitudeStatus
    char updateType
    char altitudeChange
    fixedstring subident 4
    fixedstring facility 3
    tailq_entry position_link fa_position
    double testDouble
    float testFloat
}

Running this through CTable generates a C structure that looks like this:

struct fa_position {
    long           timestamp;
    short          latitude;
    short          longitude;
    short          groundspeed;
    short          altitude;
    char           altitudeStatus;
    char           updateType;
    char           altitudeChange;
    char           subident[4];
    char           facility[3];
    TAILQ_ENTRY(fa_position)  position_link;
    double         testDouble;
    float          testFloat;
};

Defining the table generates a command of the same name.  That command
has a number of methods, the most important of which is "create".

In the above example,

    fa_position create x

Will create a new command, x, that "owns" zero or more instances of the
fa_position structure and has a number of methods for getting and setting
values, importing, traversing, counting, checking the existence of, etc,
rows in the table.

When executing that command, it will generate a new table.  The new table
will itself be a command that has a number of methods.

One of those methods will generate a cursor that can be driven through the
table.  The cursor will be able to:

* read and write values in the row being pointed to

INSTALLING
----------

set INSTDIR in the Makefile to where you want the package to be installed,
typically /usr/local/lib/ctable.  Do a "make".

-----

It also generates code to read and write the table.

The TAILQ should probably be implicit.

Defining the table will generate a command to create a table.

When executing that command, it will generate a new table.  The new table
will itself be a command that has a number of methods.

One of those methods will generate a cursor that can be driven through the
table.  The cursor will be able to:

* read and write values in the row being pointed to

* delete the row being pointed to

* insert a row before or after the current row

* set a row to default values

* search for rows containing certain characteristics

Once this can also incorporate structures within structures, it'll be
pretty strong.






ADDING SUPPORT FOR A NEW TYPE TO CTABLE
---------------------------------------

Decide what the name of your new type is, for instance "int", "float",
"double", "inet", "mac", etc.

In this example we'll add native support for IP addresses and call them "inet".

1. Add the name of the type to ctableTypes.

2. If you need any include files, add them to gen_preamble.

3. Create a proc that defines the type.

#
# inet - define an IPv4 address field
#           
proc inet {name {default 0.0.0.0}} {
    deffield $name type inet default $default
}           

4. Add code to generate an entry in the struct-defining routine "gen_struct":

            inet {
                putfield "struct in_addr" $field(name)
            }



5. Create a proc that sets the field from a passed Tcl object.  Typically
this uses subst to replace some standard variables in a code fragment:

#
# inetSetSource - code we run subst over to generate a set of an IPv4
# internet address.
#
set inetSetSource {
      case $optname: {
        if (!inet_aton (Tcl_GetString (obj), &$pointer->$field)) {
            Tcl_AppendResult (interp, "bad IP address parsing field $field", (char *)NULL);
            return TCL_ERROR;
        }

        break;
      }
}

If you can do this in a standard way, i.e. generate a source string as above
and reference $pointer and $field for the variable references, you don't
need to do a custom emit_set_*_routine, but can just use the standard one.

An example of a custom emit_set_*_routine is emit_set_num_field, which
handles multiple field types (int, long, wide and double).

6. Add a call to the emit_set_standard_field routine, referencing your
set source variable, or your custom one, to the switch statement in the 
gen_sets proc:

            inet {
                emit_set_standard_field $myfield $pointer inetSetSource
            }


7. If necessary, add an entry to the switch statement in gen_defaults_subr for generating a default value.  If a straight C assignment of your field from the default value will work, like "i = 0", you can just let it use the default.

            inet {
                emit "    inet_aton (\"$field(default)\", &$pointer->$myfield);"
            }



8. Add an entry to the switch statement in the gen_new_obj proc that creates
a Tcl object representing the pointer and field:

        inet {
            return "Tcl_NewStringObj (inet_ntoa ($pointer->$fieldName), -1)"
        }

8b. Add an entry to the switch statement in the gen_get_set_obj proc that 
sets an existing Tcl object to contain the pointer and field.

        inet {
            return "Tcl_SetStringObj ($obj, inet_ntoa ($pointer->$fieldName), -1)"
        }

NOTE that if your object is very text-oriented or Tcl_Obj-oriented you may
need to do something special in gen_gets_string_cases to have it be
efficient.  (For varstring fixedstring, and char, for example, we just return 
a pointer directly to the string inside the row itself and set the length 
from the length field that we store (varstring) or the known length field
(fixedstring and char) rather than setting a Tcl object to the string value
and then having the next step get the string rep from that.)

9. Create a CTable that incorporates your type.  Try to build it.  If it
doesn't compile cleanly, debug it.

If you get a Tcl traceback, debug the Tcl directly.

If you get a C compilation error, look at the generated code and see what
your mistake is.


