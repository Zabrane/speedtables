

$Id$

CTABLE

This is code to creates tables of rows where rows consist of fields, in Tcl.

It takes the definition of one or more tables and generates C code that can 
is then compiled and linked as a C shared library extension for Tcl,
providing high performance tables that are far more memory-efficient than
using array of lists lists of lists, Itcl objects, etc.


CTable fa_position {
    long timestamp
    short latitude
    short longitude
    short groundspeed
    short altitude
    char altitudeStatus
    char updateType
    char altitudeChange
    fixedstring subident 4
    fixedstring facility 3
    tailq_entry position_link fa_position
    double testDouble
    float testFloat
}

Running this through CTable generates a C structure that looks like this:

struct fa_position {
    long           timestamp;
    short          latitude;
    short          longitude;
    short          groundspeed;
    short          altitude;
    char           altitudeStatus;
    char           updateType;
    char           altitudeChange;
    char           subident[4];
    char           facility[3];
    TAILQ_ENTRY(fa_position)  position_link;
    double         testDouble;
    float          testFloat;
};

Defining the table generates a command of the same name.  That command
has a number of methods, the most important of which is "create".

In the above example,

    fa_position create x

Will create a new command, x, that "owns" zero or more instances of the
fa_position structure and has a number of methods for getting and setting
values, importing, traversing, counting, checking the existence of, etc,
rows in the table.

When executing that command, it will generate a new table.  The new table
will itself be a command that has a number of methods.

One of those methods will generate a cursor that can be driven through the
table.  The cursor will be able to:

* read and write values in the row being pointed to

-----

It also generates code to read and write the table.

The TAILQ should probably be implicit.

Defining the table will generate a command to create a table.

When executing that command, it will generate a new table.  The new table
will itself be a command that has a number of methods.

One of those methods will generate a cursor that can be driven through the
table.  The cursor will be able to:

* read and write values in the row being pointed to

* delete the row being pointed to

* insert a row before or after the current row

* set a row to default values

* search for rows containing certain characteristics

Once this can also incorporate structures within structures, it'll be
pretty strong.






ADDING SUPPORT FOR A NEW TYPE TO CTABLE
---------------------------------------

If you need any include files, add them to gen_preamble.

Create a proc that defines the type.

#
# inet - define an IPv4 address field
#           
proc inet {name {default 0.0.0.0}} {
    deffield $name type inet default $default
}           

Add code to generate an entry in the struct-defining routine "gen_struct":

            inet {
                putfield "struct in_addr" $field(name)
            }



Create a proc that sets the field from a passed Tcl object.  Typically
this uses subst to replace some standard variables in a code fragment:

#
# inetSetSource - code we run subst over to generate a set of an IPv4
# internet address.
#
set inetSetSource {
      case $optname: {
        if (!inet_aton (Tcl_GetString (obj), &$pointer->$field)) {
            Tcl_AppendResult (interp, "bad IP address parsing field $field", (char *)NULL);
            return TCL_ERROR;
        }

        break;
      }
}

If you can do this in a standard way, i.e. generate a source string as above
and reference $pointer and $field for the variable references, you don't
need to do a custom emit_set_*_routine, but can just use the standard one.

An example of a custom emit_set_*_routine is emit_set_num_field, which
handles multiple field types (int, long, wide and double).

Add a call to the emit_set_standard_field routine, referencing your
set source variable, or your custom one, to the switch statement in the 
gen_sets proc:

            inet {
                emit_set_standard_field $myfield $pointer inetSetSource
            }


Add an entry to the switch statement in gen_defaults_subr for generating
a default value:

            inet {
                emit "    inet_aton (\"$field(default)\", &$pointer->$myfield);"
            }



Add an entry to the switch statement in the gen_new_obj proc that creates
a Tcl object representing the pointer and field:

        inet {
            return "Tcl_NewStringObj (inet_ntoa ($pointer->$fieldName), -1)"
        }



