    // $Id$
int ${table}_delete_all_rows(Tcl_Interp *interp, struct ctableTable *ctable) {
    Tcl_HashSearch     hashSearch;
    Tcl_HashEntry     *hashEntry;
    struct ${table}   *row;

    for (hashEntry = Tcl_FirstHashEntry (ctable->keyTablePtr, &hashSearch); hashEntry != (Tcl_HashEntry *) NULL; hashEntry = Tcl_NextHashEntry (&hashSearch)) {
	row = (struct $table *) Tcl_GetHashValue (hashEntry);
	${table}_delete(row);
    }

    Tcl_DeleteHashTable (ctable->keyTablePtr);

    // reset the linked list of all rows
    ctable_ListInit (&ctable->ll_head);

    // drop all indexes, if any
    if (ctable_DropAllIndexes (interp, ctable) == TCL_ERROR) {
        return TCL_ERROR;
    }

    ctable->count = 0;
    ctable->autoRowNumber = 0;

    return TCL_OK;
}

int ${table}ObjCmd (ClientData cData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
{
    struct ctableTable *ctable = (struct ctableTable *)cData;
    struct $table *row;
    int optIndex;
    Tcl_HashEntry *hashEntry;
    int indexCtl;

    static CONST char *options[] = {"get", "set", "incr", "array_get", "array_get_with_nulls", "exists", "delete", "count", "search", "search+", "type", "import_postgres_result", "fields", "fieldtype", "needs_quoting", "names", "reset", "destroy", "statistics", "read_tabsep", "write_tabsep", "index", "foreach", (char *)NULL};

    enum options {OPT_GET, OPT_SET, OPT_INCR, OPT_ARRAY_GET, OPT_ARRAY_GET_WITH_NULLS, OPT_EXISTS, OPT_DELETE, OPT_COUNT, OPT_SEARCH, OPT_SEARCHPLUS, OPT_TYPE, OPT_IMPORT_POSTGRES_RESULT, OPT_FIELDS, OPT_FIELDTYPE, OPT_NEEDSQUOTING, OPT_NAMES, OPT_RESET, OPT_DESTROY, OPT_STATISTICS, OPT_READ_TABSEP, OPT_WRITE_TABSEP, OPT_INDEX, OPT_FOREACH};

    if (objc == 1) {
        Tcl_WrongNumArgs (interp, 1, objv, "option ?args?");
	return TCL_ERROR;
    }

    if (Tcl_GetIndexFromObj (interp, objv[1], options, "option", TCL_EXACT, &optIndex) != TCL_OK) {
	Tcl_Obj      **calloutObjv;
	int           i;
	int           result;

	hashEntry = Tcl_FindHashEntry (ctable->creatorTable->registeredProcTablePtr, Tcl_GetString (objv[1]));

	if (hashEntry == (Tcl_HashEntry *) NULL) {
	    Tcl_HashSearch hashSearch;

	    Tcl_AppendResult (interp, ", or one of the registered methods:", (char *)NULL);

	    for (hashEntry = Tcl_FirstHashEntry (ctable->creatorTable->registeredProcTablePtr, &hashSearch); hashEntry != (Tcl_HashEntry *) NULL; hashEntry = Tcl_NextHashEntry (&hashSearch)) {
	        char *key = Tcl_GetHashKey (ctable->creatorTable->registeredProcTablePtr, hashEntry);
		Tcl_AppendResult (interp, " ", key, (char *)NULL);
	    }
	    return TCL_ERROR;
	}

	calloutObjv = (Tcl_Obj **)ckalloc (sizeof (Tcl_Obj *) * objc);
	calloutObjv[0] = (Tcl_Obj *)Tcl_GetHashValue (hashEntry);
	calloutObjv[1] = objv[0];
	for (i = 2; i < objc; i++) {
	    calloutObjv[i] = objv[i];
	}
	result = Tcl_EvalObjv (interp, objc, calloutObjv, 0);
	ckfree ((void *)calloutObjv);
	return result;
    }

    switch ((enum options) optIndex) {
      case OPT_TYPE: {
          Tcl_SetObjResult (interp, Tcl_NewStringObj ("$table", -1));
	  return TCL_OK;
      }

      case OPT_FIELDS: {
          int i;
	  Tcl_Obj *resultObj = Tcl_GetObjResult(interp);

	  for (i = 0; ${table}_fields[i] != (char *) NULL; i++) {
	      if (Tcl_ListObjAppendElement (interp, resultObj, Tcl_NewStringObj (${table}_fields[i], -1)) == TCL_ERROR) {
	          return TCL_ERROR;
	      }
	  }
          return TCL_OK;
      }

      case OPT_FIELDTYPE: {
        int fieldIndex;

	if (objc != 3) {
            Tcl_WrongNumArgs (interp, 2, objv, "fieldName");
	    return TCL_ERROR;
	}

	if (Tcl_GetIndexFromObj (interp, objv[2], ${table}_fields, "field", TCL_EXACT, &fieldIndex) != TCL_OK) {
	    return TCL_ERROR;
	}
	Tcl_SetStringObj (Tcl_GetObjResult (interp), ctableTypes[(int)${table}_types[fieldIndex]], -1);
	return TCL_OK;
      }

      case OPT_NEEDSQUOTING: {
        int fieldIndex;

	if (objc != 3) {
            Tcl_WrongNumArgs (interp, 2, objv, "fieldName");
	    return TCL_ERROR;
	}

	if (Tcl_GetIndexFromObj (interp, objv[2], ${table}_fields, "field", TCL_EXACT, &fieldIndex) != TCL_OK) {
	    return TCL_ERROR;
	}
	Tcl_SetBooleanObj (Tcl_GetObjResult (interp), ${table}_needs_quoting[fieldIndex]);
	return TCL_OK;
      }


      case OPT_STATISTICS: {
          CONST char *stats = Tcl_HashStats (ctable->keyTablePtr);
	  Tcl_SetStringObj (Tcl_GetObjResult (interp), stats, -1);
	  ckfree ((void *)stats);
	  return TCL_OK;
      }

      case OPT_SEARCH: {
	return ctable_SetupAndPerformSearch (interp, objv, objc, ctable);
      }

      case OPT_SEARCHPLUS: {
	return ctable_SetupAndPerformSkipSearch (interp, objv, objc, ctable);
      }

      case OPT_NAMES: {
          Tcl_Obj        *resultObj = Tcl_GetObjResult (interp);
	  Tcl_HashSearch  hashSearch;
	  char           *pattern = (char *) NULL;
	  char           *key;

	  if (objc > 3) {
	      Tcl_WrongNumArgs (interp, 2, objv, "varName codeBody ?pattern?");
	      return TCL_ERROR;
	  }

	  if (objc == 3) {
	      pattern = Tcl_GetString (objv[2]);
	  }

	  for (hashEntry = Tcl_FirstHashEntry (ctable->keyTablePtr, &hashSearch); hashEntry != (Tcl_HashEntry *) NULL; hashEntry = Tcl_NextHashEntry (&hashSearch)) {
	      key = Tcl_GetHashKey (ctable->keyTablePtr, hashEntry);
	      if ((pattern != (char *) NULL)  && (!Tcl_StringCaseMatch (key, pattern, 1))) continue;
	      if (Tcl_ListObjAppendElement (interp, resultObj, Tcl_NewStringObj (key, -1)) == TCL_ERROR) {
	          return TCL_ERROR;
	      }
	  }
	  return TCL_OK;
      }

      case OPT_RESET: {
	  if (${table}_delete_all_rows (interp, ctable) != TCL_OK) {
	      return TCL_ERROR;
	  }
	  Tcl_InitCustomHashTable (ctable->keyTablePtr, TCL_STRING_KEYS, (Tcl_HashKeyType *)NULL);
	  return TCL_OK;
      }

      case OPT_DESTROY: {
	  if (${table}_delete_all_rows (interp, ctable) != TCL_OK) {
	      return TCL_ERROR;
	  }
          Tcl_DeleteCommandFromToken (interp, ctable->commandInfo);
	  return TCL_OK;
      }

      case OPT_DELETE: {
	hashEntry = Tcl_FindHashEntry (ctable->keyTablePtr, Tcl_GetString (objv[2]));

	if (hashEntry == (Tcl_HashEntry *) NULL) {
	    Tcl_SetBooleanObj (Tcl_GetObjResult (interp), 0);
	    return TCL_OK;
	}

	row = (struct $table *) Tcl_GetHashValue (hashEntry);

	ctable_RemoveFromAllIndexes (interp, ctable, row);
	${table}_delete(row);
	Tcl_DeleteHashEntry (hashEntry);
	ctable->count--;
	Tcl_SetBooleanObj (Tcl_GetObjResult (interp), 1);
	return TCL_OK;
      }

      case OPT_COUNT: {
          Tcl_SetIntObj (Tcl_GetObjResult (interp), ctable->count);
	  return TCL_OK;
      }

      case OPT_EXISTS: {
	hashEntry = Tcl_FindHashEntry (ctable->keyTablePtr, Tcl_GetString (objv[2]));

	if (hashEntry == (Tcl_HashEntry *) NULL) {
	    Tcl_SetBooleanObj (Tcl_GetObjResult (interp), 0);
	} else {
	    Tcl_SetBooleanObj (Tcl_GetObjResult (interp), 1);
	}
	return TCL_OK;
      }

      case OPT_SET: {
        int       i;
	int       listObjc;
	Tcl_Obj **listObjv;

	if ((objc < 3) || ((objc != 4) && (objc % 2) != 1)) {
	    Tcl_WrongNumArgs (interp, 2, objv, "key pairList or key field value ?field value...?");
	    return TCL_ERROR;
	}

        row = ${table}_find_or_create (ctable, Tcl_GetString (objv[2]), &indexCtl);

	if (objc == 4) {
	    if (Tcl_ListObjGetElements (interp, objv[3], &listObjc, &listObjv) == TCL_ERROR) {
		Tcl_AppendResult (interp, " while processing key-value list", (char *)NULL);
		return TCL_ERROR;
	    }

	    if ((listObjc % 2) != 0) {
		Tcl_AppendResult (interp, "key-value list must contain an even number of elements", (char *)NULL);
		return TCL_ERROR;
	    }

	    for (i = 0; i < listObjc; i+= 2) {
		if (${table}_set_fieldobj (interp, ctable, listObjv[i+1], row, listObjv[i], indexCtl) == TCL_ERROR) {
		    Tcl_AppendResult (interp, " while processing key-value list", (char *)NULL);
		    return TCL_ERROR;
		}
	    }
	    break;
	}

	for (i = 3; i < objc; i += 2) {
	    // printf ("i = %d\n", i);
	    if (${table}_set_fieldobj (interp, ctable, objv[i+1], row, objv[i], indexCtl) == TCL_ERROR) {
	        return TCL_ERROR;
	    }
	}
        break;
      }

      case OPT_INCR: {
        int       i;
	int       listObjc;
	Tcl_Obj **listObjv;

	if ((objc < 3) || ((objc != 4) && (objc % 2) != 1)) {
	    Tcl_WrongNumArgs (interp, 2, objv, "key pairList or key field value ?field value...?");
	    return TCL_ERROR;
	}

        row = ${table}_find_or_create (ctable, Tcl_GetString (objv[2]), &indexCtl);

	if (objc == 4) {
	    if (Tcl_ListObjGetElements (interp, objv[3], &listObjc, &listObjv) == TCL_ERROR) {
		Tcl_AppendResult (interp, " while processing key-value list", (char *)NULL);
		return TCL_ERROR;
	    }

	    if ((listObjc % 2) != 0) {
		Tcl_AppendResult (interp, "key-value list must contain an even number of elements", (char *)NULL);
		return TCL_ERROR;
	    }

	    for (i = 0; i < listObjc; i+= 2) {
		int field;

		if (Tcl_GetIndexFromObj (interp, listObjv[i], ${table}_fields, "field", TCL_EXACT, &field) != TCL_OK) {
		    return TCL_ERROR;
		}

		if (${table}_incr (interp, ctable, listObjv[i+1], row, field, indexCtl) == TCL_ERROR) {
		    Tcl_AppendResult (interp, " while processing key-value list", (char *)NULL);
		    return TCL_ERROR;
		} else {

		    if (Tcl_ListObjAppendElement (interp, Tcl_GetObjResult (interp), ${table}_get (interp, row, field)) == TCL_ERROR) {
			Tcl_AppendResult (interp, " while appending incremented value", (char *)NULL);
			return TCL_ERROR;
		    }
		}
	    }
	    break;
	}

	for (i = 3; i < objc; i += 2) {
	    // printf ("i = %d\n", i);
	    int field;

	    if (Tcl_GetIndexFromObj (interp, objv[i], ${table}_fields, "field", TCL_EXACT, &field) != TCL_OK) {
		return TCL_ERROR;
	    }

	    if (${table}_incr (interp, ctable, objv[i+1], row, field, indexCtl) == TCL_ERROR) {
		Tcl_AppendResult (interp, " while processing key-value list", (char *)NULL);
	        return TCL_ERROR;
	    }

	    if (Tcl_ListObjAppendElement (interp, Tcl_GetObjResult (interp), ${table}_get (interp, row, field)) == TCL_ERROR) {
		Tcl_AppendResult (interp, " while appending incremented value", (char *)NULL);
		return TCL_ERROR;
	    }
	}
        break;
      }

      case OPT_IMPORT_POSTGRES_RESULT: {
#ifdef WITH_PGTCL
          const PGresult   *res;
	  char             *fieldName = NULL;
	  char             *key;
	  char             *value;
	  int              *fieldList;
	  int               fieldIndex;
	  int               nFields;
	  int               nTuples;
	  int               field;
	  int               pgRow;
	  Tcl_Obj          *fieldNameObj = Tcl_NewObj();
	  Tcl_Obj          *valueObj = Tcl_NewObj();

          if (objc != 3) {
	    Tcl_WrongNumArgs (interp, 2, objv, "pgTclResultHandle");
	    return TCL_ERROR;
	  }

	  extern PGresult *PgGetResultId (Tcl_Interp *interp, CONST char *id, void **resultidPtr);

	  res = PgGetResultId (interp, Tcl_GetString (objv[2]), NULL);
	  if (res == NULL) {
	      Tcl_SetStringObj (Tcl_GetObjResult (interp), Tcl_GetString (objv[2]), -1);
	      Tcl_AppendResult (interp, " is not a valid query result", NULL);
	      return TCL_ERROR;
	  }

          nFields = PQnfields (res);

	  fieldList = (int *) ckalloc ( nFields * sizeof (int));

	  // the first field in the query result must be the key
	  for (field = 1; field < nFields; field++) {
	      fieldName = PQfname (res, field);

	      Tcl_SetStringObj (fieldNameObj, fieldName, -1);

	      if (Tcl_GetIndexFromObj (interp, fieldNameObj, ${table}_fields, "field", TCL_EXACT, &fieldIndex) != TCL_OK) {
		  Tcl_AppendResult (interp, " while matching postgres field \"", fieldName, "\" with fields from table \"${table}\"", (char *)NULL);
		  return TCL_ERROR;
	      }

	      fieldList[field] = fieldIndex;
	  }

	  nTuples = PQntuples (res);

	  for (pgRow = 0; pgRow < nTuples; pgRow++) {
	      key = PQgetvalue (res, pgRow, 0);
	      if (key == NULL) {
	          key = "";
              }

	      row = ${table}_find_or_create (ctable, key, &indexCtl);

	      for (field = 1; field < nFields; field++) {
	          value = PQgetvalue (res, pgRow, field);

		  if (value == NULL) {
		      if (PQgetisnull (res, pgRow, field)) {
			 if (${table}_set_null (interp, ctable, row, fieldList[field], indexCtl) == TCL_ERROR) {
			    Tcl_AppendResult (interp, " while setting null value for field \"", fieldName, "\" in table \"${table}\"", (char *)NULL);
		            return TCL_ERROR;
			 }
		          continue;
		      } else {
		          valueObj = ${table}_DefaultEmptyStringObj;
		      }
		  }
		  Tcl_SetStringObj (valueObj, value, -1);
		  ${table}_set (interp, ctable, valueObj, row, fieldList[field], indexCtl);
	      }
	  }

	  return TCL_OK;
#else
        Tcl_SetStringObj (Tcl_GetObjResult (interp), "this version of ctables was built without postgresql support", -1);
        return TCL_ERROR;
#endif
      }

      case OPT_WRITE_TABSEP:
      case OPT_READ_TABSEP: {
        int              fieldIds[$nFields];
	int              i;
	int              objIdx = 3;
	int              nFields = 0;
	char            *pattern = NULL;
	char            *channel;
	int              noKeys = 0;

	if (objc < 3) {
	  Tcl_WrongNumArgs (interp, 2, objv, "channel ?-glob pattern? ?-nokeys? ?field field...?");
	  return TCL_ERROR;
	}

	objc -= 3;

	while (objc > 0) {
	    char *possibleSwitch;

	    possibleSwitch = Tcl_GetString(objv[objIdx]);
	    if (*possibleSwitch != '-') break;

	    if (strcmp (possibleSwitch, "-glob") == 0) {
		objIdx++;
	        if (objc == 1) {
		    Tcl_AppendResult (interp, "-glob not followed by pattern", (char *)NULL);
		    return TCL_ERROR;
		}
		pattern = Tcl_GetString (objv[objIdx++]);
		objc -= 2;
	    } else if (strcmp (possibleSwitch, "-nokeys") == 0) {
		objIdx++;
		objc--;
		noKeys = 1;
	    } else {
		Tcl_AppendResult (interp, "unknown switch: ", possibleSwitch, (char *)NULL);
		return TCL_ERROR;
	    }
	}

	if (objc > $nFields) {
	  Tcl_WrongNumArgs (interp, 2, objv, "channel ?-glob pattern? ?-nokeys? ?field field...?");
          Tcl_AppendResult (interp, " More fields requested than exist in record", (char *)NULL);
	  return TCL_ERROR;
	}

	if (objc == 0) {
	    nFields = $nFields;
	    for (i = 0; i < $nFields; i++) {
	        fieldIds[i] = i;
	    }
	} else {
	    nFields = objc;
	    for (i = 0; i < objc; i++) {
	        if (Tcl_GetIndexFromObj (interp, objv[objIdx++], ${table}_fields, "field", TCL_EXACT, &fieldIds[i]) != TCL_OK) {
		    return TCL_ERROR;
		}
	    }
	}

	channel = Tcl_GetString (objv[2]);

	if (optIndex == OPT_WRITE_TABSEP) {
	    return ${table}_export_tabsep (interp, ctable, channel, fieldIds, nFields, pattern, noKeys);
	} else {
	    return ${table}_import_tabsep (interp, ctable, channel, fieldIds, nFields, pattern, noKeys);
	}

      }

      case OPT_INDEX: {
	static CONST char *subOptions[] = {"span", "count", "create", "drop", "indexable", "indexed", "list", "dump", (char *)NULL};
	int                suboptIndex;
	int                fieldNum;

	enum suboptions {SUBOPT_SPAN, SUBOPT_COUNT, SUBOPT_CREATE, SUBOPT_DROP, SUBOPT_INDEXABLE, SUBOPT_INDEXED, SUBOPT_LIST, SUBOPT_DUMP};

	if (objc < 3) {
	    Tcl_WrongNumArgs (interp, 2, objv, "option ?args?");
	    return TCL_ERROR;
	}

	if (Tcl_GetIndexFromObj (interp, objv[2], subOptions, "suboption", TCL_EXACT, &suboptIndex) != TCL_OK) {
	    return TCL_ERROR;
	}

	switch (suboptIndex) {
	  case SUBOPT_SPAN: {
	      if (objc != 4) {
		Tcl_WrongNumArgs (interp, 3, objv, "fieldName");
		return TCL_ERROR;
	      }

	      if (Tcl_GetIndexFromObj (interp, objv[3], ${table}_fields, "field", TCL_EXACT, &fieldNum) != TCL_OK) {
		return TCL_ERROR;
	      }

	      return ctable_LappendIndexLowAndHi (interp, ctable, fieldNum);
	  }

	  case SUBOPT_COUNT: {
	    if (objc != 4) {
		Tcl_WrongNumArgs (interp, 3, objv, "fieldName");
		return TCL_ERROR;
	    }

	    if (Tcl_GetIndexFromObj (interp, objv[3], ${table}_fields, "field", TCL_EXACT, &fieldNum) != TCL_OK) {
		return TCL_ERROR;
	    }

	    return ctable_IndexCount (interp, ctable, fieldNum);
	  }

	  case SUBOPT_CREATE: {
	    int depth = 20;

	    if ((objc < 4) || (objc > 5)) {
		Tcl_WrongNumArgs (interp, 3, objv, "fieldName ?depth?");
		return TCL_ERROR;
	    }

	    if (Tcl_GetIndexFromObj (interp, objv[3], ${table}_fields, "field", TCL_EXACT, &fieldNum) != TCL_OK) {
		return TCL_ERROR;
	    }

	    if (objc == 5) {
	        if (Tcl_GetIntFromObj (interp, objv[4], &depth) == TCL_ERROR) {
		    return TCL_ERROR;
		}
	    }

	    if (ctable_CreateIndex (interp, ctable, fieldNum, depth) != TCL_OK) {
	        return TCL_ERROR;
	    }
	    break;
	  }

	  case SUBOPT_DROP: {
	    if (objc != 4) {
		Tcl_WrongNumArgs (interp, 3, objv, "fieldName");
		return TCL_ERROR;
	    }

	    if (Tcl_GetIndexFromObj (interp, objv[3], ${table}_fields, "field", TCL_EXACT, &fieldNum) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (ctable_DropIndex (interp, ctable, fieldNum) != TCL_OK) {
	        return TCL_ERROR;
	    }
	    break;
	  }

	  case SUBOPT_INDEXABLE: {
	      int field;

	      // for each field, if the index number in the creator table's
	      // per-field structure is >= 0 then lappend the field name
	      // to the Tcl result object

	      for (field = 0; field < ctable->creatorTable->nFields; field++) {
	          struct ctableFieldInfo *f = ctable->creatorTable->fields[field];

		  if (f->indexNumber >= 0) {
		      if (Tcl_ListObjAppendElement (interp, Tcl_GetObjResult (interp), f->nameObj) == TCL_ERROR) {
		          return TCL_ERROR;
		      }
		  }
	      }
	      break;
	  }

	  case SUBOPT_INDEXED: {
	      int field;

	      // for each field if the skipList pointer for that table is
	      // non-null, lappend the field name

	      for (field = 0; field < ctable->creatorTable->nFields; field++) {
	          if (ctable->skipLists[field] != NULL) {
		      if (Tcl_ListObjAppendElement (interp, Tcl_GetObjResult (interp), ctable->creatorTable->fields[field]->nameObj) == TCL_ERROR) {
		          return TCL_ERROR;
		      }
		  }
	      }
	      break;
	  }

	  case SUBOPT_DUMP: {
	    if (objc != 4) {
		Tcl_WrongNumArgs (interp, 3, objv, "fieldName");
		return TCL_ERROR;
	    }

	    if (Tcl_GetIndexFromObj (interp, objv[3], ${table}_fields, "field", TCL_EXACT, &fieldNum) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (ctable_DumpIndex (interp, ctable, fieldNum) != TCL_OK) {
	        return TCL_ERROR;
	    }
	    break;
	  }

	  case SUBOPT_LIST: {
	    if (objc != 4) {
		Tcl_WrongNumArgs (interp, 3, objv, "fieldName");
		return TCL_ERROR;
	    }

	    if (Tcl_GetIndexFromObj (interp, objv[3], ${table}_fields, "field", TCL_EXACT, &fieldNum) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (ctable_ListIndex (interp, ctable, fieldNum) != TCL_OK) {
	        return TCL_ERROR;
	    }
	    break;
	  }
	}

	return TCL_OK;
      }

      case OPT_GET: {
        int i;

	if (objc < 3) {
	    Tcl_WrongNumArgs (interp, 2, objv, "key ?field...?");
	    return TCL_ERROR;
	}

	row = ${table}_find (ctable, Tcl_GetString (objv[2]));
	if (row == (struct $table *) NULL) {
	    return TCL_OK;
	}

	if (objc == 3) {
	    Tcl_SetObjResult (interp, ${table}_genlist (interp, row));
	    return TCL_OK;
	}

	for (i = 3; i < objc; i++) {
	    if (${table}_lappend_fieldobj (interp, row, objv[i]) == TCL_ERROR) {
	        return TCL_ERROR;
	    }
	}
        break;
      }

      case OPT_ARRAY_GET_WITH_NULLS: {
        int i;

	if (objc < 3) {
	    Tcl_WrongNumArgs (interp, 2, objv, "key ?field...?");
	    return TCL_ERROR;
	}

	row = ${table}_find (ctable, Tcl_GetString (objv[2]));
	if (row == (struct $table *) NULL) {
	    return TCL_OK;
	}

	if (objc == 3) {
	    Tcl_SetObjResult (interp,  ${table}_gen_keyvalue_list (interp, row));
	    return TCL_OK;
	}

	for (i = 3; i < objc; i++) {
	    if (${table}_lappend_field_and_nameobj (interp, row, objv[i]) == TCL_ERROR) {
	        return TCL_ERROR;
	    }
	}
        break;
      }

      case OPT_ARRAY_GET: {
        int i;

	if (objc < 3) {
	    Tcl_WrongNumArgs (interp, 2, objv, "key ?field...?");
	    return TCL_ERROR;
	}

	row = ${table}_find (ctable, Tcl_GetString (objv[2]));
	if (row == (struct $table *) NULL) {
	    return TCL_OK;
	}

	if (objc == 3) {
	    Tcl_SetObjResult (interp,  ${table}_gen_nonnull_keyvalue_list (interp, row));
	    return TCL_OK;
	}

	for (i = 3; i < objc; i++) {
	    if (${table}_lappend_nonnull_field_and_nameobj (interp, row, objv[i]) == TCL_ERROR) {
	        return TCL_ERROR;
	    }
	}
        break;
      }

      case OPT_FOREACH: {
	  Tcl_HashSearch  hashSearch;
	  char           *pattern = (char *) NULL;
	  char           *key;
	  int             codeIndex = 3;

	  if ((objc < 4) || (objc > 5)) {
	      Tcl_WrongNumArgs (interp, 2, objv, "varName ?pattern? codeBody");
	      return TCL_ERROR;
	  }

	  if (objc == 5) {
	      pattern = Tcl_GetString (objv[3]);
	      codeIndex = 4;
	  }

	  for (hashEntry = Tcl_FirstHashEntry (ctable->keyTablePtr, &hashSearch); hashEntry != (Tcl_HashEntry *) NULL; hashEntry = Tcl_NextHashEntry (&hashSearch)) {
	      key = Tcl_GetHashKey (ctable->keyTablePtr, hashEntry);
	      if ((pattern != (char *) NULL) && (!Tcl_StringCaseMatch (key, pattern, 1))) continue;
	      if (Tcl_ObjSetVar2 (interp, objv[2], (Tcl_Obj *)NULL, Tcl_NewStringObj (key, -1), TCL_LEAVE_ERR_MSG) == (Tcl_Obj *) NULL) {
	          return TCL_ERROR;
	      }
	      switch (Tcl_EvalObjEx (interp, objv[codeIndex], 0)) {
	        case TCL_ERROR:
		  Tcl_AppendResult (interp, " while processing foreach code body", (char *) NULL);
		  return TCL_ERROR;

		case TCL_OK:
		case TCL_CONTINUE:
		  break;

		case TCL_BREAK:
		  return TCL_OK;

		case TCL_RETURN:
		  return TCL_RETURN;
	      }
	  }
	  return TCL_OK;
      }
    }

    return TCL_OK;
}

