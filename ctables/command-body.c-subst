// $Id$

int ${table}_delete_all_rows(Tcl_Interp *interp, CTable *ctable) {
    ctable_BaseRow           *row;
    ctable_BaseRow           *nextRow;

    CTABLE_LIST_FOREACH_SAFE (ctable->ll_head, row, nextRow, 0) {

	// we say CTABLE_INDEX_PRIVATE to cause the index entries
	// to not be deleted, drop all indexes later will do a
	// much faster job

	// explicitly delete the hash entry - since we are fast-deleting
	// the hash table buckets and not updating all the links, we
	// gotta free key strings here or they don't get freed.  slight kludge.
	// gotta do it before ${table}_delete because afterwards, the row
	// is already deleted.
        ckfree (row->hashEntry.key);
	// Remove the freed key, because it *is* possible for a private table
	// to have a valid key. Alternatively, we could remove this free and
	// depend on ${table}_delete doing it.
	row->hashEntry.key = 0;

	${table}_delete(ctable, (struct ${table} *)row, CTABLE_INDEX_PRIVATE);

    }

    // reset the linked list of all rows
    ctable_ListInit (&ctable->ll_head);

    // drop all indexes, if any
    ctable_DeleteHashTable (ctable->keyTablePtr);

    ctable_DropAllIndexes (ctable);

    ctable->count = 0;
    ctable->autoRowNumber = 0;

    return TCL_OK;
}

int ${table}ObjCmd (ClientData cData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
{
    CTable *ctable = (CTable *)cData;
    struct $table *row;
    int optIndex;
    ctable_HashEntry *hashEntry;
    Tcl_HashEntry *registeredProcHashEntry;
    int indexCtl;

    static CONST char *options[] = {"get", "set", "store", "incr", "array_get", "array_get_with_nulls", "exists", "delete", "count", "batch", "search", "search+", "type", "import_postgres_result", "fields", "field", "fieldtype", "needs_quoting", "names", "reset", "destroy", "statistics", "read_tabsep", "write_tabsep", "index", "foreach", "capabilities", "key", "makekey", "methods",
#ifdef WITH_SHARED_TABLES
								"attach",
#endif
		(char *)NULL};

    enum options {OPT_GET, OPT_SET, OPT_STORE, OPT_INCR, OPT_ARRAY_GET, OPT_ARRAY_GET_WITH_NULLS, OPT_EXISTS, OPT_DELETE, OPT_COUNT, OPT_BATCH, OPT_SEARCH, OPT_SEARCHPLUS, OPT_TYPE, OPT_IMPORT_POSTGRES_RESULT, OPT_FIELDS, OPT_FIELD, OPT_FIELDTYPE, OPT_NEEDSQUOTING, OPT_NAMES, OPT_RESET, OPT_DESTROY, OPT_STATISTICS, OPT_READ_TABSEP, OPT_WRITE_TABSEP, OPT_INDEX, OPT_FOREACH, OPT_CAPS, OPT_KEY, OPT_MAKEKEY, OPT_METHODS,
#ifdef WITH_SHARED_TABLES
			OPT_ATTACH,
#endif
					NUM_OPTIONS
		};

#ifdef WITH_SHARED_TABLES
    // Options allowed in shared tables
    static enum options shared_options[] = { OPT_ATTACH, OPT_METHODS, OPT_CAPS, OPT_DESTROY, OPT_NEEDSQUOTING, OPT_FIELDTYPE, OPT_FIELD, OPT_FIELDS, OPT_TYPE, OPT_SEARCHPLUS, OPT_SEARCH, NUM_OPTIONS };
    static int shared_ok[NUM_OPTIONS] = {-1};

    if(shared_ok[0] == -1) {
	int i;
	for(i = 0; i < NUM_OPTIONS; i++)
	    shared_ok[i] = FALSE;
	for(i = 0; shared_options[i] != NUM_OPTIONS; i++)
	    shared_ok[shared_options[i]] = TRUE;
    }
#endif

    if (objc == 1) {
        Tcl_WrongNumArgs (interp, 1, objv, "option ?args?");
	return TCL_ERROR;
    }

    if (Tcl_GetIndexFromObj (interp, objv[1], options, "option", TCL_EXACT, &optIndex) != TCL_OK) {
	Tcl_Obj      **calloutObjv;
	int           i;
	int           result;

	registeredProcHashEntry = Tcl_FindHashEntry (ctable->creator->registeredProcTablePtr, Tcl_GetString (objv[1]));

	if (registeredProcHashEntry == (Tcl_HashEntry *) NULL) {
	    Tcl_HashSearch hashSearch;

	    Tcl_AppendResult (interp, ", or one of the registered methods:", (char *)NULL);

	    for (registeredProcHashEntry = Tcl_FirstHashEntry (ctable->creator->registeredProcTablePtr, &hashSearch); registeredProcHashEntry != (Tcl_HashEntry *) NULL; registeredProcHashEntry = Tcl_NextHashEntry (&hashSearch)) {
	        char *key = Tcl_GetHashKey (ctable->creator->registeredProcTablePtr, registeredProcHashEntry);
		Tcl_AppendResult (interp, " ", key, (char *)NULL);
	    }
	    return TCL_ERROR;
	}

	calloutObjv = (Tcl_Obj **)ckalloc (sizeof (Tcl_Obj *) * objc);
	calloutObjv[0] = (Tcl_Obj *)Tcl_GetHashValue (registeredProcHashEntry);
	calloutObjv[1] = objv[0];
	for (i = 2; i < objc; i++) {
	    calloutObjv[i] = objv[i];
	}
	result = Tcl_EvalObjv (interp, objc, calloutObjv, 0);
	ckfree ((void *)calloutObjv);
	return result;
    }

#ifdef WITH_SHARED_TABLES
    if (ctable->share_type == CTABLE_SHARED_READER) {
      if (!shared_ok[optIndex]) {
	Tcl_AppendResult (interp, "Command '", options(optIndex), "' is not possible in a shared reader table.", (char *)NULL);
	return TCL_ERROR;
      }
    }
#endif

    switch ((enum options) optIndex) {
      case NUM_OPTIONS: { // Can't happen!
	  Tcl_AppendResult (interp, "Can't happen.", (char *)NULL);
	  return TCL_ERROR;
      }

      case OPT_TYPE: {
          Tcl_SetObjResult (interp, Tcl_NewStringObj ("$table", -1));
	  return TCL_OK;
      }

      case OPT_FIELDS: {
          int i;

	  Tcl_Obj *obj;
	  Tcl_Obj *resultObj = Tcl_GetObjResult(interp);

	  if (objc != 2) {
	    Tcl_WrongNumArgs (interp, 1, objv, "fields");
	    return TCL_ERROR;
	  }

	  for (i = 0; (obj = ${table}_NameObjList[i]) != NULL; i++) {
	      if (!is_hidden_obj(obj) && Tcl_ListObjAppendElement (interp, resultObj, obj) == TCL_ERROR) {
	          return TCL_ERROR;
	      }
	  }

	  return TCL_OK;
      }

#ifdef WITH_SHARED_TABLES
      // attach to shared memory table, search only
      case OPT_ATTACH: {
	  int         listObjc;
	  Tcl_Obj   **listObjv;

	  if (objc < 3) {
	      Tcl_WrongNumArgs (interp, 2, objv, "pairList or field value ?field value...?");
	      return TCL_ERROR;
	  }

	  if (objc == 3) {
	      // If there's precisely one element in the list, get a new list
	      // vector from the first element
	      if (Tcl_ListObjGetElements (interp, objv[2], &listObjc, &listObjv) == TCL_ERROR) {
		  Tcl_AppendResult (interp, " while processing key-value list", (char *)NULL);
		  return TCL_ERROR;
	      }
	  } else {
	      // new list vector is the old list vector
	      listObjc = objc - 2;
	      listObjv = (Tcl_Obj **)objv + 2;
	  }
	  
	  if ((listObjc % 2) != 0) {
	      Tcl_AppendResult (interp, "key-value list must contain an even number of elements", (char *)NULL);
	      return TCL_ERROR;
	  }

	  return ${table}_attach(listObjc, listObjv);
      }
#endif

      // return a capabilities list (stub)
      case OPT_CAPS: {
	  return TCL_OK;
      }

      // return the key
      case OPT_KEY: {
	  Tcl_SetObjResult (interp, ${table}_NameObjList[${table}_keyField]);
	  return TCL_OK;
      }

      case OPT_METHODS: {
          int i;

	  Tcl_Obj *resultObj = Tcl_GetObjResult(interp);
	  Tcl_HashSearch hashSearch;

	  if (objc != 2) {
	      Tcl_WrongNumArgs (interp, 1, objv, "keys");
	      return TCL_ERROR;
	  }

	  for (i = 0; options[i] != NULL; i++) {
	      if (Tcl_ListObjAppendElement (interp, resultObj, Tcl_NewStringObj (options[i], -1)) == TCL_ERROR) {
	          return TCL_ERROR;
	      }
	  }

	  for (registeredProcHashEntry = Tcl_FirstHashEntry (ctable->creator->registeredProcTablePtr, &hashSearch); registeredProcHashEntry != (Tcl_HashEntry *) NULL; registeredProcHashEntry = Tcl_NextHashEntry (&hashSearch)) {
	      if (Tcl_ListObjAppendElement (interp, resultObj, Tcl_NewStringObj (Tcl_GetHashKey (ctable->creator->registeredProcTablePtr, registeredProcHashEntry), -1)) == TCL_ERROR) {
	          return TCL_ERROR;
	      }
	  }

	  return TCL_OK;
      }

      case OPT_FIELD: {
	static CONST char *subOptions[] = {"getprop", "properties", "proplist", (char *)NULL};
	int                      suboptIndex;
	int                      fieldNum;
	int                      propIndex;
        ctable_FieldInfo        *f;
      Tcl_Obj                   *resultObj = Tcl_GetObjResult (interp);

	enum suboptions {SUBOPT_GETPROP, SUBOPT_PROPERTIES, SUBOPT_PROPLIST};

	if ((objc < 4) || (objc > 5)) {
	    Tcl_WrongNumArgs (interp, 2, objv, "fieldName opt ?arg?");
	    return TCL_ERROR;
	}

        if (Tcl_GetIndexFromObj (interp, objv[2], ${table}_fields, "field", TCL_EXACT, &fieldNum) != TCL_OK) {
	  return TCL_ERROR;
        }

	if (Tcl_GetIndexFromObj (interp, objv[3], subOptions, "suboption", TCL_EXACT, &suboptIndex) != TCL_OK) {
	    return TCL_ERROR;
	}

        f = ctable->creator->fields[fieldNum];

	switch (suboptIndex) {

	  case SUBOPT_GETPROP: {
	    if (objc != 5) {
	      Tcl_WrongNumArgs (interp, 3, objv, "fieldName propName");
	      return TCL_ERROR;
	    }

	    if (Tcl_GetIndexFromObj (interp, objv[4], (CONST char **)f->propKeys, "property", TCL_EXACT, &propIndex) != TCL_OK) {
	        return TCL_ERROR;
	    }

	    Tcl_SetStringObj (resultObj, f->propValues[propIndex], -1);
	    return TCL_OK;
	  }

	  case SUBOPT_PROPERTIES: {
	      int i;

	      if (objc != 4) {
		Tcl_WrongNumArgs (interp, 3, objv, "fieldName");
		return TCL_ERROR;
	      }

	      for (i = 0; f->propKeys[i] != NULL; i++) {
		  if (Tcl_ListObjAppendElement (interp, resultObj, Tcl_NewStringObj (f->propKeys[i], -1)) == TCL_ERROR) {
		      return TCL_OK;
		  }
	      }

	      return TCL_OK;
	  }

	  case SUBOPT_PROPLIST: {
	      int i;

	      if (objc != 4) {
		Tcl_WrongNumArgs (interp, 3, objv, "fieldName");
		return TCL_ERROR;
	      }

	      for (i = 0; f->propKeys[i] != NULL; i++) {
		  if (Tcl_ListObjAppendElement (interp, resultObj, Tcl_NewStringObj (f->propKeys[i], -1)) == TCL_ERROR) {
		      return TCL_OK;
	          }

		  if (Tcl_ListObjAppendElement (interp, resultObj, Tcl_NewStringObj (f->propValues[i], -1)) == TCL_ERROR) {
		      return TCL_OK;
	          }
	      }
	      return TCL_OK;
	  }
        }
	panic ("\"impossible\" path followed");
      }

      case OPT_FIELDTYPE: {
        int fieldIndex;

	if (objc != 3) {
            Tcl_WrongNumArgs (interp, 2, objv, "fieldName");
	    return TCL_ERROR;
	}

	if (Tcl_GetIndexFromObj (interp, objv[2], ${table}_fields, "field", TCL_EXACT, &fieldIndex) != TCL_OK) {
	    return TCL_ERROR;
	}
	Tcl_SetStringObj (Tcl_GetObjResult (interp), ctableTypes[(int)${table}_types[fieldIndex]], -1);
	return TCL_OK;
      }

      case OPT_NEEDSQUOTING: {
        int fieldIndex;

	if (objc != 3) {
            Tcl_WrongNumArgs (interp, 2, objv, "fieldName");
	    return TCL_ERROR;
	}

	if (Tcl_GetIndexFromObj (interp, objv[2], ${table}_fields, "field", TCL_EXACT, &fieldIndex) != TCL_OK) {
	    return TCL_ERROR;
	}
	Tcl_SetBooleanObj (Tcl_GetObjResult (interp), ${table}_needs_quoting[fieldIndex]);
	return TCL_OK;
      }


      case OPT_STATISTICS: {
          CONST char *stats = ctable_HashStats (ctable->keyTablePtr);
	  Tcl_SetStringObj (Tcl_GetObjResult (interp), stats, -1);
	  ckfree ((void *)stats);
	  return TCL_OK;
      }

      case OPT_BATCH: {
	if (objc != 3) {
            Tcl_WrongNumArgs (interp, 2, objv, "batchList");
	    return TCL_ERROR;
	}

	return ctable_RunBatch (interp, ctable, objv[0], objv[2]);
      }

      case OPT_SEARCH: {
	return ctable_SetupAndPerformSearch (interp, objv, objc, ctable, CTABLE_SEARCH_INDEX_NONE);
      }

      case OPT_SEARCHPLUS: {
	return ctable_SetupAndPerformSearch (interp, objv, objc, ctable, CTABLE_SEARCH_INDEX_ANY);
      }

      case OPT_NAMES: {
          Tcl_Obj           *resultObj = Tcl_GetObjResult (interp);
	  ctable_HashSearch  hashSearch;
	  char              *pattern = (char *) NULL;
	  char              *key;

	  if (objc > 3) {
	      Tcl_WrongNumArgs (interp, 2, objv, "varName codeBody ?pattern?");
	      return TCL_ERROR;
	  }

	  if (objc == 3) {
	      pattern = Tcl_GetString (objv[2]);
	  }

	  for (hashEntry = ctable_FirstHashEntry (ctable->keyTablePtr, &hashSearch); hashEntry != (ctable_HashEntry *) NULL; hashEntry = ctable_NextHashEntry (&hashSearch)) {
	      key = hashEntry->key;
	      if ((pattern != (char *) NULL)  && (!Tcl_StringCaseMatch (key, pattern, 1))) continue;
	      if (Tcl_ListObjAppendElement (interp, resultObj, Tcl_NewStringObj (key, -1)) == TCL_ERROR) {
	          return TCL_ERROR;
	      }
	  }
	  return TCL_OK;
      }

      case OPT_RESET: {
	  if (${table}_delete_all_rows (interp, ctable) != TCL_OK) {
	      return TCL_ERROR;
	  }
	  ctable_InitHashTable (ctable->keyTablePtr);
	  return TCL_OK;
      }

      case OPT_DESTROY: {
	  if (${table}_delete_all_rows (interp, ctable) != TCL_OK) {
	      return TCL_ERROR;
	  }
          Tcl_DeleteCommandFromToken (interp, ctable->commandInfo);
	  return TCL_OK;
      }

      case OPT_DELETE: {
	hashEntry = ctable_FindHashEntry (ctable->keyTablePtr, Tcl_GetString (objv[2]));

	if (hashEntry == (ctable_HashEntry *) NULL) {
	    Tcl_SetBooleanObj (Tcl_GetObjResult (interp), 0);
	    return TCL_OK;
	}

	row = (struct $table *) hashEntry;

	${table}_delete(ctable, row, CTABLE_INDEX_NORMAL);
	ctable->count--;
	Tcl_SetBooleanObj (Tcl_GetObjResult (interp), 1);
	return TCL_OK;
      }

      case OPT_COUNT: {
          Tcl_SetIntObj (Tcl_GetObjResult (interp), ctable->count);
	  return TCL_OK;
      }

      case OPT_EXISTS: {
	hashEntry = ctable_FindHashEntry (ctable->keyTablePtr, Tcl_GetString (objv[2]));

	if (hashEntry == (ctable_HashEntry *) NULL) {
	    Tcl_SetBooleanObj (Tcl_GetObjResult (interp), 0);
	} else {
	    Tcl_SetBooleanObj (Tcl_GetObjResult (interp), 1);
	}
	return TCL_OK;
      }

      case OPT_MAKEKEY:
      case OPT_STORE: {
        int         i;
	int         listObjc;
	Tcl_Obj   **listObjv;
	char	   *key;
        Tcl_Obj    *keyObj;
	static char keyString[32];

	if (objc < 3) {
	    Tcl_WrongNumArgs (interp, 2, objv, "pairList or field value ?field value...?");
	    return TCL_ERROR;
	}

	if (objc == 3) {
	    // If there's precisely one element in the list, get a new list
	    // vector from the first element
	    if (Tcl_ListObjGetElements (interp, objv[2], &listObjc, &listObjv) == TCL_ERROR) {
		Tcl_AppendResult (interp, " while processing key-value list", (char *)NULL);
		return TCL_ERROR;
	    }
	} else {
	    // new list vector is the old list vector
	    listObjc = objc - 2;
	    listObjv = (Tcl_Obj **)objv + 2;
	}

	if ((listObjc % 2) != 0) {
	    Tcl_AppendResult (interp, "key-value list must contain an even number of elements", (char *)NULL);
	    return TCL_ERROR;
	}

	keyObj = ${table}_key_from_keylist(interp, listObjv, listObjc);

	if(optIndex == OPT_MAKEKEY) {
	    if(!keyObj) {
	        Tcl_AppendResult (interp, "Key not found in list", (char *)NULL);
		return TCL_ERROR;
	    }
	    Tcl_SetObjResult (interp, keyObj);
	    return TCL_OK;
	}

	if(keyObj) {
	    key = Tcl_GetString(keyObj);
	} else {
	    sprintf(key = keyString, "%u", ctable->autoRowNumber++);
        }

        row = ${table}_find_or_create (ctable, key, &indexCtl);

	for (i = 0; i < listObjc; i+= 2) {
	    if (${table}_set_fieldobj (interp, ctable, listObjv[i+1], row, listObjv[i], indexCtl) == TCL_ERROR) {
		Tcl_AppendResult (interp, " while processing key-value list", (char *)NULL);
		return TCL_ERROR;
	    }
	}

        Tcl_SetObjResult (interp, Tcl_NewStringObj (key, -1));

	break;
      }

      case OPT_SET: {
        int       i;
	int       listObjc;
	Tcl_Obj **listObjv;

	if ((objc < 3) || ((objc != 4) && (objc % 2) != 1)) {
	    Tcl_WrongNumArgs (interp, 2, objv, "key pairList or key field value ?field value...?");
	    return TCL_ERROR;
	}

        row = ${table}_find_or_create (ctable, Tcl_GetString (objv[2]), &indexCtl);

	if (objc == 4) {
	    // If there's precisely one element in the list, get a new list
	    // vector from the first element
	    if (Tcl_ListObjGetElements (interp, objv[3], &listObjc, &listObjv) == TCL_ERROR) {
		Tcl_AppendResult (interp, " while processing key-value list", (char *)NULL);
		return TCL_ERROR;
	    }
	} else {
	    // new list vector is the old list vector
	    listObjc = objc - 3;
	    listObjv = (Tcl_Obj **)objv + 3;
	}

	if ((listObjc % 2) != 0) {
	    Tcl_AppendResult (interp, "key-value list must contain an even number of elements", (char *)NULL);
	    return TCL_ERROR;
	}

	for (i = 0; i < listObjc; i+= 2) {
	    if (${table}_set_fieldobj (interp, ctable, listObjv[i+1], row, listObjv[i], indexCtl) == TCL_ERROR) {
		Tcl_AppendResult (interp, " while processing key-value list", (char *)NULL);
		return TCL_ERROR;
	    }
	}

	break;
      }

      case OPT_INCR: {
        int       i;
	int       listObjc;
	Tcl_Obj **listObjv;

	if ((objc < 3) || ((objc != 4) && (objc % 2) != 1)) {
	    Tcl_WrongNumArgs (interp, 2, objv, "key pairList or key field value ?field value...?");
	    return TCL_ERROR;
	}

        row = ${table}_find_or_create (ctable, Tcl_GetString (objv[2]), &indexCtl);

	if (objc == 4) {
	    if (Tcl_ListObjGetElements (interp, objv[3], &listObjc, &listObjv) == TCL_ERROR) {
		Tcl_AppendResult (interp, " while processing key-value list", (char *)NULL);
		return TCL_ERROR;
	    }

	    if ((listObjc % 2) != 0) {
		Tcl_AppendResult (interp, "key-value list must contain an even number of elements", (char *)NULL);
		return TCL_ERROR;
	    }

	    for (i = 0; i < listObjc; i+= 2) {
		int field;

		if (Tcl_GetIndexFromObj (interp, listObjv[i], ${table}_fields, "field", TCL_EXACT, &field) != TCL_OK) {
		    return TCL_ERROR;
		}

		if (${table}_incr (interp, ctable, listObjv[i+1], row, field, indexCtl) == TCL_ERROR) {
		    Tcl_AppendResult (interp, " while processing key-value list", (char *)NULL);
		    return TCL_ERROR;
		} else {

		    if (Tcl_ListObjAppendElement (interp, Tcl_GetObjResult (interp), ${table}_get (interp, row, field)) == TCL_ERROR) {
			Tcl_AppendResult (interp, " while appending incremented value", (char *)NULL);
			return TCL_ERROR;
		    }
		}
	    }
	    break;
	}

	for (i = 3; i < objc; i += 2) {
	    // printf ("i = %d\n", i);
	    int field;

	    if (Tcl_GetIndexFromObj (interp, objv[i], ${table}_fields, "field", TCL_EXACT, &field) != TCL_OK) {
		return TCL_ERROR;
	    }

	    if (${table}_incr (interp, ctable, objv[i+1], row, field, indexCtl) == TCL_ERROR) {
		Tcl_AppendResult (interp, " while processing key-value list", (char *)NULL);
	        return TCL_ERROR;
	    }

	    if (Tcl_ListObjAppendElement (interp, Tcl_GetObjResult (interp), ${table}_get (interp, row, field)) == TCL_ERROR) {
		Tcl_AppendResult (interp, " while appending incremented value", (char *)NULL);
		return TCL_ERROR;
	    }
	}
        break;
      }

      case OPT_IMPORT_POSTGRES_RESULT: {
#ifdef WITH_PGTCL
          const PGresult   *res;
	  char             *fieldName = NULL;
	  char             *key = NULL;
	  char             *value;
	  int              *fieldList;
	  int               fieldIndex;
	  int               nFields;
	  int               nTuples;
	  int               field;
	  int               noKeys = 0;
	  int               pgRow;
	  Tcl_Obj          *fieldNameObj = Tcl_NewObj();
	  Tcl_Obj          *valueObj = Tcl_NewObj();
	  char              keyNumberString[32];
	  int		    keyColumn;
	  int		    firstColumn;

	  extern PGresult *PgGetResultId (Tcl_Interp *interp, CONST char *id, void **resultidPtr);

          if ((objc < 3) || (objc > 4)) {
	    arg_err:
	      Tcl_WrongNumArgs (interp, 2, objv, "pgTclResultHandle ?-nokeys?");
	      return TCL_ERROR;
	  }

	  if (objc == 4) {
	      if (strcmp (Tcl_GetString (objv[3]), "-nokeys") != 0) {
	          goto arg_err;
	      }
	      noKeys = 1;
	  }

	  res = PgGetResultId (interp, Tcl_GetString (objv[2]), NULL);
	  if (res == NULL) {
	      Tcl_SetStringObj (Tcl_GetObjResult (interp), Tcl_GetString (objv[2]), -1);
	      Tcl_AppendResult (interp, " is not a valid query result", NULL);
	      return TCL_ERROR;
	  }

          nFields = PQnfields (res);

	  fieldList = (int *) ckalloc ( nFields * sizeof (int));

	  if (noKeys) {
	      // if called with "-nokeys", there is no default key column
	      keyColumn = -1;
	      firstColumn = 0;
	  } else {
	      // if not called with "-nokeys", the first field in the query
	      // result is the default key column
	      keyColumn = 0;
	      firstColumn = 1;
	  }

	  for (field = firstColumn; field < nFields; field++) {
	      fieldName = PQfname (res, field);

	      Tcl_SetStringObj (fieldNameObj, fieldName, -1);

	      if (Tcl_GetIndexFromObj (interp, fieldNameObj, ${table}_fields, "field", TCL_EXACT, &fieldIndex) != TCL_OK) {
		  Tcl_AppendResult (interp, " while matching postgres field \"", fieldName, "\" with fields from table \"${table}\"", (char *)NULL);
		  return TCL_ERROR;
	      }

	      fieldList[field] = fieldIndex;

	      // If any column matches the key, then use it. This means
	      // ignoring the first column if noKeys wasn't set.
	      if(${table}_keyField == fieldIndex) {
	          keyColumn = field;
	      }
	  }

	  nTuples = PQntuples (res);

	  for (pgRow = firstColumn; pgRow < nTuples; pgRow++) {
	      if(keyColumn == -1) {
	          sprintf (keyNumberString, "%d", ctable->autoRowNumber++);
	          key = keyNumberString;
	      } else {
	          key = PQgetvalue(res, pgRow, keyColumn);
	      }

	      row = ${table}_find_or_create (ctable, key, &indexCtl);

	      for (field = firstColumn; field < nFields; field++) {
		  if(field == keyColumn) {
		      continue;
		  }

	          value = PQgetvalue (res, pgRow, field);

		  if (value == NULL) {
		      if (PQgetisnull (res, pgRow, field)) {
			  if (${table}_set_null (interp, ctable, row, fieldList[field], indexCtl) == TCL_ERROR) {
			      Tcl_AppendResult (interp, " while setting null value for field \"", fieldName, "\" in table \"${table}\"", (char *)NULL);
		              return TCL_ERROR;
			  }
		          continue;
		      } else {
		          valueObj = ${table}_DefaultEmptyStringObj;
		      }
		  }
		  Tcl_SetStringObj (valueObj, value, -1);
		  ${table}_set (interp, ctable, valueObj, row, fieldList[field], indexCtl);
	      }
	  }

	  if (noKeys && key != NULL) {
	      Tcl_SetObjResult (interp, Tcl_NewStringObj (key, -1));
	  }

	  return TCL_OK;
#else
        Tcl_SetStringObj (Tcl_GetObjResult (interp), "this version of ctables was built without postgresql support", -1);
        return TCL_ERROR;
#endif
      }

      case OPT_WRITE_TABSEP:
      case OPT_READ_TABSEP: {
        int              fieldIds[$nFields];
	int              i;
	int              objIdx = 3;
	int              nFields = 0;
	char            *pattern = NULL;
	char            *channel;
	int              noKeys = 0;

	if (objc < 3) {
	  Tcl_WrongNumArgs (interp, 2, objv, "channel ?-glob pattern? ?-nokeys? ?field field...?");
	  return TCL_ERROR;
	}

	objc -= 3;

	while (objc > 0) {
	    char *possibleSwitch;

	    possibleSwitch = Tcl_GetString(objv[objIdx]);
	    if (*possibleSwitch != '-') break;

	    if (strcmp (possibleSwitch, "-glob") == 0) {
		objIdx++;
	        if (objc == 1) {
		    Tcl_AppendResult (interp, "-glob not followed by pattern", (char *)NULL);
		    return TCL_ERROR;
		}
		pattern = Tcl_GetString (objv[objIdx++]);
		objc -= 2;
	    } else if (strcmp (possibleSwitch, "-nokeys") == 0) {
		objIdx++;
		objc--;
		noKeys = 1;
	    } else {
		Tcl_AppendResult (interp, "unknown switch: ", possibleSwitch, (char *)NULL);
		return TCL_ERROR;
	    }
	}

	if (objc > $nFields) {
	  Tcl_WrongNumArgs (interp, 2, objv, "channel ?-glob pattern? ?-nokeys? ?field field...?");
          Tcl_AppendResult (interp, " More fields requested than exist in record", (char *)NULL);
	  return TCL_ERROR;
	}

	if (objc == 0) {
	    for (nFields = i = 0; i < $nFields; i++) {
		if(!is_hidden_name(${table}_fields,i)) {
	            fieldIds[nFields++] = i;
		}
	    }
	} else {
	    nFields = objc;
	    for (i = 0; i < objc; i++) {
	        if (Tcl_GetIndexFromObj (interp, objv[objIdx++], ${table}_fields, "field", TCL_EXACT, &fieldIds[i]) != TCL_OK) {
		    return TCL_ERROR;
		}
	    }
	}

	channel = Tcl_GetString (objv[2]);

#ifdef MANIACDEBUGGER
{
  char buffer[9999];
  char *s=buffer;
  
  for(i = 0; i < nFields; i++) {
    sprintf(s, "%d, ", fieldIds[i]);
    s += strlen(s);
  }
  if(s > buffer) {
    --s;
    --s;
    *s = 0;
  }

  fprintf(stderr,
	"${table}_%s_tabsep (interp, ctable, %s, {%s}, %d, \"%s\", %d);\n",
	optIndex == OPT_WRITE_TABSEP ? "export" : "import",
	channel, buffer, nFields, pattern, noKeys
  );
}
#endif

	if (optIndex == OPT_WRITE_TABSEP) {
	    return ${table}_export_tabsep (interp, ctable, channel, fieldIds, nFields, pattern, noKeys);
	} else {
	    return ${table}_import_tabsep (interp, ctable, channel, fieldIds, nFields, pattern, noKeys);
	}

      }

      case OPT_INDEX: {
	static CONST char *subOptions[] = {"span", "count", "create", "drop", "indexable", "indexed", "unique", "list", "dump", (char *)NULL};
	int                suboptIndex;
	int                fieldNum;

	enum suboptions {SUBOPT_SPAN, SUBOPT_COUNT, SUBOPT_CREATE, SUBOPT_DROP, SUBOPT_INDEXABLE, SUBOPT_INDEXED, SUBOPT_UNIQUE, SUBOPT_LIST, SUBOPT_DUMP};

	if (objc < 3) {
	    Tcl_WrongNumArgs (interp, 2, objv, "option ?args?");
	    return TCL_ERROR;
	}

	if (Tcl_GetIndexFromObj (interp, objv[2], subOptions, "suboption", TCL_EXACT, &suboptIndex) != TCL_OK) {
	    return TCL_ERROR;
	}

	switch (suboptIndex) {
	  case SUBOPT_SPAN: {
	      if (objc != 4) {
		Tcl_WrongNumArgs (interp, 3, objv, "fieldName");
		return TCL_ERROR;
	      }

	      if (Tcl_GetIndexFromObj (interp, objv[3], ${table}_fields, "field", TCL_EXACT, &fieldNum) != TCL_OK) {
		return TCL_ERROR;
	      }

	      return ctable_LappendIndexLowAndHi (interp, ctable, fieldNum);
	  }

	  case SUBOPT_COUNT: {
	    if (objc != 4) {
		Tcl_WrongNumArgs (interp, 3, objv, "fieldName");
		return TCL_ERROR;
	    }

	    if (Tcl_GetIndexFromObj (interp, objv[3], ${table}_fields, "field", TCL_EXACT, &fieldNum) != TCL_OK) {
		return TCL_ERROR;
	    }

	    return ctable_IndexCount (interp, ctable, fieldNum);
	  }

	  case SUBOPT_CREATE: {
	    int depth = 20;

	    if ((objc < 4) || (objc > 5)) {
		Tcl_WrongNumArgs (interp, 3, objv, "fieldName ?depth?");
		return TCL_ERROR;
	    }

	    if (Tcl_GetIndexFromObj (interp, objv[3], ${table}_fields, "field", TCL_EXACT, &fieldNum) != TCL_OK) {
		return TCL_ERROR;
	    }

	    if (objc == 5) {
	        if (Tcl_GetIntFromObj (interp, objv[4], &depth) == TCL_ERROR) {
		    return TCL_ERROR;
		}
	    }

	    if (ctable_CreateIndex (interp, ctable, fieldNum, depth) != TCL_OK) {
	        return TCL_ERROR;
	    }
	    break;
	  }

	  case SUBOPT_DROP: {
	    if (objc != 4) {
		Tcl_WrongNumArgs (interp, 3, objv, "fieldName");
		return TCL_ERROR;
	    }

	    if (Tcl_GetIndexFromObj (interp, objv[3], ${table}_fields, "field", TCL_EXACT, &fieldNum) != TCL_OK) {
		return TCL_ERROR;
	    }

	    ctable_DropIndex (ctable, fieldNum);
	    break;
	  }

	  case SUBOPT_INDEXABLE: {
	      int field;

	      // for each field, if the index number in the creator table's
	      // per-field structure is >= 0 then lappend the field name
	      // to the Tcl result object

	      for (field = 0; field < ctable->creator->nFields; field++) {
	          ctable_FieldInfo *f = ctable->creator->fields[field];

		  if (f->indexNumber >= 0) {
		      if (Tcl_ListObjAppendElement (interp, Tcl_GetObjResult (interp), f->nameObj) == TCL_ERROR) {
		          return TCL_ERROR;
		      }
		  }
	      }
	      break;
	  }

	  case SUBOPT_INDEXED: {
	      int field;

	      // for each field if the skipList pointer for that table is
	      // non-null, lappend the field name

	      for (field = 0; field < ctable->creator->nFields; field++) {
	          if (ctable->skipLists[field] != NULL) {
		      if (Tcl_ListObjAppendElement (interp, Tcl_GetObjResult (interp), ctable->creator->fields[field]->nameObj) == TCL_ERROR) {
		          return TCL_ERROR;
		      }
		  }
	      }
	      break;
	  }

	  case SUBOPT_UNIQUE: {
	    if (objc != 4) {
		Tcl_WrongNumArgs (interp, 3, objv, "fieldName");
		return TCL_ERROR;
	    }

	    if (Tcl_GetIndexFromObj (interp, objv[3], ${table}_fields, "field", TCL_EXACT, &fieldNum) != TCL_OK) {
		return TCL_ERROR;
	    }

	    Tcl_SetBooleanObj (Tcl_GetObjResult (interp), ctable->creator->fields[fieldNum]->unique);
	    return TCL_OK;
	  }

	  case SUBOPT_DUMP: {
	    if (objc != 4) {
		Tcl_WrongNumArgs (interp, 3, objv, "fieldName");
		return TCL_ERROR;
	    }

	    if (Tcl_GetIndexFromObj (interp, objv[3], ${table}_fields, "field", TCL_EXACT, &fieldNum) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (ctable_DumpIndex (interp, ctable, fieldNum) != TCL_OK) {
	        return TCL_ERROR;
	    }
	    break;
	  }

	  case SUBOPT_LIST: {
	    if (objc != 4) {
		Tcl_WrongNumArgs (interp, 3, objv, "fieldName");
		return TCL_ERROR;
	    }

	    if (Tcl_GetIndexFromObj (interp, objv[3], ${table}_fields, "field", TCL_EXACT, &fieldNum) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (ctable_ListIndex (interp, ctable, fieldNum) != TCL_OK) {
	        return TCL_ERROR;
	    }
	    break;
	  }
	}

	return TCL_OK;
      }

      case OPT_GET: {
        int i;

	if (objc < 3) {
	    Tcl_WrongNumArgs (interp, 2, objv, "key ?field...?");
	    return TCL_ERROR;
	}

	row = ${table}_find (ctable, Tcl_GetString (objv[2]));
	if (row == (struct $table *) NULL) {
	    return TCL_OK;
	}

	if (objc == 3) {
	    Tcl_SetObjResult (interp, ${table}_genlist (interp, row));
	    return TCL_OK;
	}

	for (i = 3; i < objc; i++) {
	    if (${table}_lappend_fieldobj (interp, row, objv[i]) == TCL_ERROR) {
	        return TCL_ERROR;
	    }
	}
        break;
      }

      case OPT_ARRAY_GET_WITH_NULLS: {
        int i;

	if (objc < 3) {
	    Tcl_WrongNumArgs (interp, 2, objv, "key ?field...?");
	    return TCL_ERROR;
	}

	row = ${table}_find (ctable, Tcl_GetString (objv[2]));
	if (row == (struct $table *) NULL) {
	    return TCL_OK;
	}

	if (objc == 3) {
	    Tcl_SetObjResult (interp,  ${table}_gen_keyvalue_list (interp, row));
	    return TCL_OK;
	}

	for (i = 3; i < objc; i++) {
	    if (${table}_lappend_field_and_nameobj (interp, row, objv[i]) == TCL_ERROR) {
	        return TCL_ERROR;
	    }
	}
        break;
      }

      case OPT_ARRAY_GET: {
        int i;

	if (objc < 3) {
	    Tcl_WrongNumArgs (interp, 2, objv, "key ?field...?");
	    return TCL_ERROR;
	}

	row = ${table}_find (ctable, Tcl_GetString (objv[2]));
	if (row == (struct $table *) NULL) {
	    return TCL_OK;
	}

	if (objc == 3) {
	    Tcl_SetObjResult (interp,  ${table}_gen_nonnull_keyvalue_list (interp, row));
	    return TCL_OK;
	}

	for (i = 3; i < objc; i++) {
	    if (${table}_lappend_nonnull_field_and_nameobj (interp, row, objv[i]) == TCL_ERROR) {
	        return TCL_ERROR;
	    }
	}
        break;
      }

      case OPT_FOREACH: {
	  ctable_HashSearch  hashSearch;
	  char              *pattern = (char *) NULL;
	  char              *key;
	  int                codeIndex = 3;

	  if ((objc < 4) || (objc > 5)) {
	      Tcl_WrongNumArgs (interp, 2, objv, "varName ?pattern? codeBody");
	      return TCL_ERROR;
	  }

	  if (objc == 5) {
	      pattern = Tcl_GetString (objv[3]);
	      codeIndex = 4;
	  }

	  for (hashEntry = ctable_FirstHashEntry (ctable->keyTablePtr, &hashSearch); hashEntry != (ctable_HashEntry *) NULL; hashEntry = ctable_NextHashEntry (&hashSearch)) {
	      key = hashEntry->key;
	      if ((pattern != (char *) NULL) && (!Tcl_StringCaseMatch (key, pattern, 1))) continue;
	      if (Tcl_ObjSetVar2 (interp, objv[2], (Tcl_Obj *)NULL, Tcl_NewStringObj (key, -1), TCL_LEAVE_ERR_MSG) == (Tcl_Obj *) NULL) {
	          return TCL_ERROR;
	      }
	      switch (Tcl_EvalObjEx (interp, objv[codeIndex], 0)) {
	        case TCL_ERROR:
		  Tcl_AppendResult (interp, " while processing foreach code body", (char *) NULL);
		  return TCL_ERROR;

		case TCL_OK:
		case TCL_CONTINUE:
		  break;

		case TCL_BREAK:
		  return TCL_OK;

		case TCL_RETURN:
		  return TCL_RETURN;
	      }
	  }
	  return TCL_OK;
      }
    }

    return TCL_OK;
}

