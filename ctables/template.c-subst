/*
 * CTables
 *
 * define the following variables and subst this to define a metatable command:
 *
 *  rowStructHeadTable - the table that knows about all tables of this
 *   structure type
 *
 *  rowStructTable - an instance of the table defined by the create method
 *   of this command
 *
 *  rowStruct - the C structure describing a row of the table
 *
 *  tableCommand - the name this table-creating command will have
 *
 *  implementationCommand - the command that created tables will execute
 *   to obtain their functionality.
 *
 * $Id$
 *
 */

int
${table}MetaObjCmd(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
{
    int      optIndex;


    static CONST char *options[] = {
        "create", "info", "null_value", "method", (char *)NULL
    };

    enum options
    {
        OPT_CREATE, OPT_INFO, OPT_NULLVALUE, OPT_METHOD
    };

    struct ctableCreatorTable *row_head_tbl_ptr = (struct ctableCreatorTable *)clientData;

    struct ctableTable *row_tbl_ptr;

    if (objc < 2 || objc > 4) {
      err:
	Tcl_WrongNumArgs (interp, 1, objv, "subcommand ?object? ?args?");
	return TCL_ERROR;
    }

    if (Tcl_GetIndexFromObj(interp, objv[1], options, "option", TCL_EXACT,
        &optIndex) != TCL_OK)
    {
	    return TCL_ERROR;
    }

    switch ((enum options) optIndex) {
	char      *commandName;

        case OPT_CREATE: {
	    int baseNameLength = 0;

	    if (objc != 3) {
		Tcl_WrongNumArgs (interp, 2, objv, "name");
		return TCL_ERROR;
	    }

	    row_tbl_ptr = (struct ctableTable *)ckalloc (sizeof(struct ctableTable));
	    row_tbl_ptr->creatorTable = row_head_tbl_ptr;
	    row_tbl_ptr->keyTablePtr = (Tcl_HashTable *)ckalloc (sizeof (Tcl_HashTable));
	    row_tbl_ptr->count = 0;
	    Tcl_InitCustomHashTable (row_tbl_ptr->keyTablePtr, TCL_STRING_KEYS, NULL);
	    commandName = Tcl_GetString(objv[2]);

	    if (strcmp (commandName, "#auto") == 0) {
		char *objName;

	        objName = Tcl_GetStringFromObj (objv[0], &baseNameLength);
		baseNameLength += 42;
		commandName = ckalloc (baseNameLength);
		snprintf (commandName, baseNameLength, "%s%lu", objName, row_head_tbl_ptr->nextAutoCounter++);
	    }

	    row_tbl_ptr->commandInfo = Tcl_CreateObjCommand (interp, commandName, ${table}ObjCmd, (ClientData) row_tbl_ptr, NULL);

	    Tcl_SetStringObj (Tcl_GetObjResult (interp), commandName, -1);
	    if (baseNameLength) {
	        ckfree (commandName);
	    }

	    return TCL_OK;
	}

	case OPT_INFO:
	    if (objc != 2) goto err;
	    return TCL_OK;

	case OPT_NULLVALUE:
	    if (objc > 3) {
		Tcl_WrongNumArgs (interp, 2, objv, "?newValue?");
	    }

	    if (objc == 2) {
	        Tcl_SetObjResult (interp, ${table}_NullValueObj);
		return TCL_OK;
	    }

            Tcl_DecrRefCount (${table}_NullValueObj);
	    ${table}_NullValueObj = objv[2];
	    Tcl_IncrRefCount (objv[2]);
	    Tcl_SetObjResult (interp, objv[2]);
	    return TCL_OK;

	case OPT_METHOD:
	{
	    /* register a new command into the class -- there's a name which
	     * is, like, a method name, and a proc which will be invoked
	     * when the method is invoked
	     */
	    Tcl_HashEntry *hashEntry;
	    int            new;

	    if (objc != 4) {
		Tcl_WrongNumArgs (interp, 2, objv, "name proc");
		return TCL_ERROR;
	    }
	    hashEntry = Tcl_CreateHashEntry (row_head_tbl_ptr->registeredProcTablePtr, Tcl_GetString (objv[2]), &new);
	    Tcl_IncrRefCount(objv[3]);
	    Tcl_SetHashValue (hashEntry, (ClientData)objv[3]);
	    return TCL_OK;
	}
    }

    panic("never expected to get here");
    return TCL_ERROR;
}

