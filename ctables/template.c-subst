/*
 * CTables
 *
 * define the following variables and subst this to define a metatable command:
 *
 *  rowStructHeadTable - the table that knows about all tables of this
 *   structure type
 *
 *  rowStructTable - an instance of the table defined by the create method
 *   of this command
 *
 *  rowStruct - the C structure describing a row of the table
 *
 *  tableCommand - the name this table-creating command will have
 *
 *  implementationCommand - the command that created tables will execute
 *   to obtain their functionality.
 *
 * $Id$
 *
 */

int
${table}MetaObjCmd(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
{
    int      optIndex;
#ifdef WITH_SHARED_TABLES
    mapinfo *mapinfo;
#endif

    static CONST char *options[] = {
        "create", "info", "null_value", "method", "cextension",
	(char *)NULL
    };

    enum options
    {
        OPT_CREATE, OPT_INFO, OPT_NULLVALUE, OPT_METHOD, OPT_CEXTENSION
    };

#ifdef WITH_SHARED_TABLES
    static const char *types[] = { "master", "reader", (char *)NULL };

    enum types { CREATE_MASTER, CREATE_READER };

    static int share_types[] = { CTABLE_SHARED_MASTER, CTABLE_SHARED_READER };
#endif

    ctable_CreatorTable *creator = (ctable_CreatorTable *)clientData;

    CTable *ctable;

    if (objc < 2 || objc > 4) {
      err:
	Tcl_WrongNumArgs (interp, 1, objv, "subcommand ?object? ?args?");
	return TCL_ERROR;
    }

    if (Tcl_GetIndexFromObj(interp, objv[1], options, "option", TCL_EXACT,
        &optIndex) != TCL_OK)
    {
	    return TCL_ERROR;
    }

    switch ((enum options) optIndex) {
	char      *commandName;

        case OPT_CREATE: {
	    int i;
	    int baseNameLength = 0;

#ifdef WITH_SHARED_TABLES
	    int typeIndex = -1;
	    int share_type = CTABLE_SHARED_NONE;
	    char *share_file = NULL;

	    if (objc <= 6 && objc >= 4) {
		if(Tcl_GetIndexFromObj(interp, objv[3], types, "type", TCL_EXACT, &typeIndex) != TCL_OK)
		{
		    return TCL_ERROR;
		}
		share_type = share_types[typeIndex];
		if(share_type == CTABLE_SHARED_MASTER) {
		    if(objc == 4) {
			Tcl_WrongNumArgs (interp, 2, objv, "name master filename ?size?");
		    }
		    share_file = Tcl_GetString(objv[4]);
		    if(objc == 6) {
			char *s = Tcl_GetString(objv[5]);
			size_t size = 0;
			while(isdigit(*s)) {
			    size = size * 10 + *s - '0';
			    s++;
			}
			switch(toupper(*s)) {
			    case 'G': size *= 1024;
			    case 'M': size *= 1024;
			    case 'K': size *= 1024;
				s++;
			}
			if(*s) {
			    Tcl_AppendResult("Bad size, must be an integer optionally followed by 'k', 'm', or 'g': ", Tcl_GetString(objv[5]), NULL);
			    return TCL_ERROR;
			}
		    } else {
			size = DEFAULT_SHARED_MEMORY_SIZE;
		    }
		    mapinfo = create_and_map_share(share_file, size);
		    if(!mapinfo) {
			Tcl_AppendResult("Can't map shared memory for ", share_file, NULL);
			return TCL_ERROR;
		    }
		} else if(objc != 4) {
		    Tcl_WrongNumArgs (interp, 2, objv, "name reader");
		}
	    }
	    else
#endif
	    if (objc != 3) {
		Tcl_WrongNumArgs (interp, 2, objv, "name");
		return TCL_ERROR;
	    }

#ifdef WITH_SHARED_TABLES
	    if(share_type == CTABLE_SHARED_MASTER)
		ctable = (CTable *)shmalloc (mapinfo, sizeof(CTable));
	    else
#endif
	        ctable = (CTable *)ckalloc (sizeof(CTable));

	    ctable->creator = creator;
	    ctable->keyTablePtr = (ctable_HashTable *)ckalloc (sizeof (ctable_HashTable));
	    ctable->count = 0;
	    ctable->autoRowNumber = 0;
#ifdef WITH_SHARED_TABLES
	    ctable->share_type = share_type;
	    ctable->share_file = share_file;
	    if(share_type == CTABLE_SHARED_MASTER)
		ctable->share_mapinfo = mapinfo;
	    else
		ctable->share_mapinfo = NULL;
#endif

	    // create an array of pointers to possible skip lists,
	    // one per field
#ifdef WITH_SHARED_TABLES
	    if(share_type == CTABLE_SHARED_MASTER)
	        ctable->skipLists = (jsw_skip_t **)shmalloc (mapinfo, creator->nFields * sizeof (jsw_skip_t *));
	    else
#endif
		ctable->skipLists = (jsw_skip_t **)ckalloc (creator->nFields * sizeof (jsw_skip_t *));

	    for (i = 0; i < creator->nFields; i++) {
		ctable->skipLists[i] = NULL;
	    }

	    // create an array of pointers to possible linked lists,
	    // one for each wanted as determined by gentable
	    ctable_ListInit (&ctable->ll_head);

	    ctable_InitHashTable (ctable->keyTablePtr);
	    commandName = Tcl_GetString(objv[2]);

	    if (strcmp (commandName, "#auto") == 0) {
		char *objName;

	        objName = Tcl_GetStringFromObj (objv[0], &baseNameLength);
		baseNameLength += 42;
		commandName = ckalloc (baseNameLength);
		snprintf (commandName, baseNameLength, "%s%lu", objName, creator->nextAutoCounter++);
	    }

	    ctable->commandInfo = Tcl_CreateObjCommand (interp, commandName, ${table}ObjCmd, (ClientData) ctable, NULL);

	    Tcl_SetStringObj (Tcl_GetObjResult (interp), commandName, -1);
	    if (baseNameLength) {
	        ckfree (commandName);
	    }

	    return TCL_OK;
	}

	case OPT_INFO:
	    if (objc != 2) goto err;
	    return TCL_OK;

	case OPT_NULLVALUE:
	    if (objc > 3) {
		Tcl_WrongNumArgs (interp, 2, objv, "?newValue?");
	    }

	    if (objc == 2) {
	        Tcl_SetObjResult (interp, ${table}_NullValueObj);
		return TCL_OK;
	    }

            Tcl_DecrRefCount (${table}_NullValueObj);
	    ${table}_NullValueObj = objv[2];
	    Tcl_IncrRefCount (objv[2]);
	    Tcl_SetObjResult (interp, objv[2]);
	    return TCL_OK;

	case OPT_METHOD:
	{
	    /* register a new command into the class -- there's a name which
	     * is, like, a method name, and a proc which will be invoked
	     * when the method is invoked
	     */
	    Tcl_HashEntry *hashEntry;
	    int               new;

	    if (objc != 4) {
		Tcl_WrongNumArgs (interp, 2, objv, "name proc");
		return TCL_ERROR;
	    }
	    hashEntry = Tcl_CreateHashEntry (creator->registeredProcTablePtr, Tcl_GetString (objv[2]), &new);
	    Tcl_IncrRefCount(objv[3]);
	    Tcl_SetHashValue (hashEntry, (ClientData)objv[3]);
	    return TCL_OK;
	}

	case OPT_CEXTENSION: {
	    Tcl_SetStringObj (Tcl_GetObjResult (interp), "$::ctable::extension", -1);
	    return TCL_OK;
	}
    }

    panic("never expected to get here");
    return TCL_ERROR;
}

