/*
 * CTables
 *
 * define the following variables and subst this to define a metatable command:
 *
 *  rowStructHeadTable - the table that knows about all tables of this
 *   structure type
 *
 *  rowStructTable - an instance of the table defined by the create method
 *   of this command
 *
 *  rowStruct - the C structure describing a row of the table
 *
 *  tableCommand - the name this table-creating command will have
 *
 *  implementationCommand - the command that created tables will execute
 *   to obtain their functionality.
 *
 * $Id$
 *
 */

int
${table}MetaObjCmd(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
{
    int      optIndex;

    static CONST char *options[] = {
        "create", "info", "null_value", "method", "cextension",
	(char *)NULL
    };

    enum options
    {
        OPT_CREATE, OPT_INFO, OPT_NULLVALUE, OPT_METHOD, OPT_CEXTENSION
    };

#ifdef WITH_SHARED_TABLES
    static const char *types[] = { "master", "reader", (char *)NULL };

    enum types { CREATE_MASTER, CREATE_READER };

    static int share_types[] = { CTABLE_SHARED_MASTER, CTABLE_SHARED_READER };
#endif

    ctable_CreatorTable *creator = (ctable_CreatorTable *)clientData;

    CTable *ctable = NULL;

    if (objc < 2) {
      err:
	Tcl_WrongNumArgs (interp, 1, objv, "subcommand ?object? ?args?");
	return TCL_ERROR;
    }

    if (Tcl_GetIndexFromObj(interp, objv[1], options, "option", TCL_EXACT,
        &optIndex) != TCL_OK)
    {
	    return TCL_ERROR;
    }

    switch ((enum options) optIndex) {

        case OPT_CREATE: {
	    int i;
	    int baseNameLength = 0;
	    char      *commandName;
#ifdef WITH_SHARED_TABLES
	    int typeIndex = -1;
	    int share_type = CTABLE_SHARED_NONE;
	    char *share_file = NULL;
	    char *share_name = NULL;
	    shm_t *share = NULL;
	    size_t size = 0;
	    CTable *share_ctable = NULL;
#endif

	    commandName = Tcl_GetString(objv[2]);

	    if (strcmp (commandName, "#auto") == 0) {
		char *objName;

	        objName = Tcl_GetStringFromObj (objv[0], &baseNameLength);
		baseNameLength += 42;
		commandName = ckalloc (baseNameLength);
		snprintf (commandName, baseNameLength, "%s%lu", objName, creator->nextAutoCounter++);
	    }

#ifdef WITH_SHARED_TABLES
	    if(!share_name) share_name = commandName;

	    if (objc >= 5) {
		if(Tcl_GetIndexFromObj(interp, objv[3], types, "type", TCL_EXACT, &typeIndex) != TCL_OK)
		    goto createError;

		share_type = share_types[typeIndex];
		if(share_type == CTABLE_SHARED_MASTER) {
		    if(objc > 6) {
			Tcl_WrongNumArgs (interp, 2, objv, "name master filename ?size?");
			goto createError;
		    } else if(objc == 6) {
			if (TclGetSizeFromObj(interp, objv[5], &size) != TCL_OK) {
			    Tcl_AppendResult(interp, " reading 'size'", NULL);
			    goto createError;
			}
		    }

		    share_file = Tcl_GetString(objv[4]);
		    if(!size) {
			size = DEFAULT_SHARED_SIZE;
		    }
		    if(doCreateOrAttach(interp, share_name, share_file, size, &share) != TCL_OK)
			goto createError;
		} else {
		    int i;
		    for(i = 5; i < objc; i+=2) {
			if(strcmp(Tcl_GetString(objv[i]), "file") == 0)
			    share_file = Tcl_GetString(objv[i+1]);
			else if(strcmp(Tcl_GetString(objv[i]), "name") == 0)
			    share_name = Tcl_GetString(objv[i+1]);
		    }
		    if(doCreateOrAttach(interp, share_name, share_file, ATTACH_ONLY, &share) != TCL_OK)
			goto createError;
		    share_ctable = (CTable *)get_symbol(share, share_name, SYM_TYPE_DATA);
		    if(!share_ctable) {
		        Tcl_AppendResult(interp, "No data in ", share_file, " tagged with ", share_name, NULL);
		        goto createError;
		    }
		}
	    }
	    else
#endif
	    if (objc != 3) {
		Tcl_WrongNumArgs (interp, 2, objv, "name");
		goto createError;
	    }

#ifdef WITH_SHARED_TABLES
	    if(share_type == CTABLE_SHARED_MASTER) {
		ctable = (CTable *)shmalloc (share, sizeof(CTable));
		if(!ctable) {
		    TclShmError(interp, share_name);
		    goto createError;
		}
		ctable->skipLists = NULL; // to tell if we can safely dealloc
		ctable->defaultStrings = NULL;
		ctable->share_file = NULL;
		if(!add_symbol(share, share_name, (char *)ctable, SYM_TYPE_DATA)) {
		    Tcl_AppendResult(interp, "Can not save ctable name in share", NULL);
		    goto createError;
		}
	    } else
#endif
	        ctable = (CTable *)ckalloc (sizeof(CTable));

	    ctable->creator = creator;
	    ctable->keyTablePtr = (ctable_HashTable *)ckalloc (sizeof (ctable_HashTable));
	    ctable->count = 0;
	    ctable->autoRowNumber = 0;
#ifdef WITH_SHARED_TABLES
	    ctable->share_type = share_type;
	    if(share_file) {
	        ctable->share_file = ckalloc(strlen(share_file)+1);
		strcpy(ctable->share_file, share_file);
	    } else
		ctable->share_file = NULL;
	    ctable->share = share;
	    ctable->share_ctable = share_ctable;

	    // call out for this, it's a little complex
	    ${table}_setupDefaultStrings(ctable);

	    if(share_type == CTABLE_SHARED_READER) {
		// use the skiplists and so on from the master.
		ctable->skipLists = ctable->share_ctable->skipLists;
		ctable->ll_head = ctable->share_ctable->ll_head;
		ctable->keyTablePtr = NULL;
	    } else {
		// create an array of pointers to possible skip lists,
		// one per field
	        if(share_type == CTABLE_SHARED_MASTER)
	            ctable->skipLists = (jsw_skip_t **)shmalloc (share, creator->nFields * sizeof (jsw_skip_t *));
	        else
#endif
		    ctable->skipLists = (jsw_skip_t **)ckalloc (creator->nFields * sizeof (jsw_skip_t *));

	        for (i = 0; i < creator->nFields; i++) {
		    ctable->skipLists[i] = NULL;
	        }

	        // create an array of pointers to possible linked lists,
	        // one for each wanted as determined by gentable
	        ctable_ListInit (&ctable->ll_head);

	        ctable_InitHashTable (ctable->keyTablePtr);
#ifdef WITH_SHARED_TABLES
	    }
#endif

	    ctable->commandInfo = Tcl_CreateObjCommand (interp, commandName, ${table}ObjCmd, (ClientData) ctable, NULL);

	    Tcl_SetStringObj (Tcl_GetObjResult (interp), commandName, -1);
	    if (baseNameLength) {
	        ckfree (commandName);
	    }

	    return TCL_OK;

          createError:
	    if (baseNameLength) {
	        ckfree (commandName);
	    }

#ifdef WITH_SHARED_TABLES
	    if (share_type == CTABLE_SHARED_READER) {
		ctable = NULL;
	    }

	    if(ctable) {
		if(ctable->share_file) ckfree(ctable->share_file);
	    }

	    if(share_type == CTABLE_SHARED_MASTER) {
		if(ctable) {
		    if(ctable->defaultStrings)
			shmfree(share, (void *)ctable->defaultStrings);
		    if(ctable->skipLists)
			shmfree(share, (void *)ctable->skipLists);
		    shmfree (share, (void *)ctable);
		    ctable = NULL;
		}
	    }

	    if(share) doDetach(interp, share);
#endif
	    if(ctable)
		ckfree((void *)ctable);

	    return TCL_ERROR;
	}

	case OPT_INFO:
	    if (objc != 2) goto err;
	    return TCL_OK;

	case OPT_NULLVALUE:
	    if (objc > 3) {
		Tcl_WrongNumArgs (interp, 2, objv, "?newValue?");
	    }

	    if (objc == 2) {
	        Tcl_SetObjResult (interp, ${table}_NullValueObj);
		return TCL_OK;
	    }

            Tcl_DecrRefCount (${table}_NullValueObj);
	    ${table}_NullValueObj = objv[2];
	    Tcl_IncrRefCount (objv[2]);
	    Tcl_SetObjResult (interp, objv[2]);
	    return TCL_OK;

	case OPT_METHOD:
	{
	    /* register a new command into the class -- there's a name which
	     * is, like, a method name, and a proc which will be invoked
	     * when the method is invoked
	     */
	    Tcl_HashEntry *hashEntry;
	    int               new;

	    if (objc != 4) {
		Tcl_WrongNumArgs (interp, 2, objv, "name proc");
		return TCL_ERROR;
	    }
	    hashEntry = Tcl_CreateHashEntry (creator->registeredProcTablePtr, Tcl_GetString (objv[2]), &new);
	    Tcl_IncrRefCount(objv[3]);
	    Tcl_SetHashValue (hashEntry, (ClientData)objv[3]);
	    return TCL_OK;
	}

	case OPT_CEXTENSION: {
	    Tcl_SetStringObj (Tcl_GetObjResult (interp), "$::ctable::extension", -1);
	    return TCL_OK;
	}
    }

    panic("never expected to get here");
    return TCL_ERROR;
}

